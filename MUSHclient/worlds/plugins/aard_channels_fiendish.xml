<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- Bits of this plugin and ideas were borrowed and remixed from the MUSHclient community. http://www.gammon.com.au/forum/?id=9385 and others. -->
<!-- Modifications for Aardwolf and a bunch of extra awesome sauce added by Fiendish with help from Orogan -->

<muclient>
<plugin
   name="Aardwolf_Chat_Capture_Miniwindow"
   author="Fiendish"
   id="b555825a4a5700c35fa80780"
   language="Lua"
   purpose="Move chats to a miniwindow"
   date_written="2010-10-25"
   requires="4.73"
   version="2.0"
   save_state="y"
   sequence="-9000"
>
<!-- sequence must be before echo plugin to capture unechoed info -->
<description trim="y">
USAGE:

   chats show       : show chats window
   chats hide       : hide chats window

   Left-click a line to copy it to the clipboard
   Left-click-and-drag title bar to move window
   Right-click window to see menu of options
</description>

</plugin>

<triggers>
<trigger
   enabled="n"
   name="remort_auction"
   match="^Remort Auction:.+$"
   regexp="y"
   script="untagged_info"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="global_quest"
   match="^Global Quest:.+$"
   regexp="y"
   script="untagged_info"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="info"
   match="^INFO:.+$"
   regexp="y"
   script="untagged_info"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="raidinfo"
   match="^RAIDINFO:.+$"
   regexp="y"
   script="untagged_info"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="claninfo"
   match="^CLANINFO:.+$"
   regexp="y"
   script="untagged_info"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="warfare"
   match="^(WARFARE|GENOCIDE):.+$"
   regexp="y"
   script="untagged_info"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="^\*.+[^*]$"
   regexp="y"
   omit_from_output="n"
   script="rsocial"
   sequence="100"
></trigger>

</triggers>

<aliases>

<alias
   match="resetaard"
   enabled="y"
   sequence="100"
   ignore_case="y"
   script="reset_aard"
></alias>

<alias
   script="chat_show"
   match="chats show"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="chat_hide"
   match="chats hide"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

</aliases>

<script>
<![CDATA[

require "movewindow"  -- load the movewindow.lua module
require "copytable"
require "gmcphelper"

SCROLL_BAR_WIDTH = 15
MAX_LINES = 10000 -- how many lines to store in scrollback

-- date_format = "[%d %b %H:%M:%S] "   -- [30 Aug 13:29:49]   date and time 24 hour
-- date_format = "[%d %b %I:%M:%S%p] " -- [30 Aug 01:20:12PM] date and time 12 hour
-- date_format = "[%H:%M:%S] "         -- [13:29:08]          time 24 hour
-- date_format = "[%X] "               -- [1:22:06 PM]        time 12 hour

default_width = 657
default_height = 131
default_x = 0
default_y = 0

date_format = GetVariable("date_format") or "[%d %b %H:%M:%S] "
width = tonumber(GetVariable("WINDOW_WIDTH")) or default_width
height = tonumber(GetVariable("WINDOW_HEIGHT")) or default_height
log_to_file = tonumber(GetVariable("log_to_file")) or 0
log_colour_codes = tonumber(GetVariable("log_colour_codes")) or 1
log_timestamps = tonumber(GetVariable("log_timestamps")) or 1

-- colours
WINDOW_BACKGROUND_COLOUR = GetNormalColour(1)
WINDOW_TEXT_COLOUR = 0xffffff
SCROLL_BACKGROUND_COLOUR = 0xE8E8E8
SCROLL_BAR_COLOUR = 0x111111
SCROLL_DETAIL_COLOUR = 0x000000
WINDOW_BORDER_COLOUR = 0xE8E8E8

-- offset of text from edge
TEXT_INSET = 5

-- where to store the chat line
lines = {}  -- table of recent chat lines
rawlines = {}

lineStart = ""
lineEnd = ""
WINDOW_LINES = ""

-- functions for handling Aardwolf color codes
dofile(GetPluginInfo(GetPluginID(), 20) .. "aardwolf_colors.lua")

font_height = ""
line_height = ""
windowinfo = ""
startx = ""
starty = ""

show_donations = tonumber(GetVariable("show_donations")) or 1
info_on = tonumber(GetVariable("info_on")) or 0
global_quest_on = tonumber(GetVariable("global_quest_on")) or 0
remort_auction_on = tonumber(GetVariable("remort_auction_on")) or 0
warfare_on = tonumber(GetVariable("warfare_on")) or 0
SetTriggerOption("warfare", "enabled", warfare_on)
SetTriggerOption("info", "enabled", info_on)
SetTriggerOption("raidinfo", "enabled", info_on)
SetTriggerOption("claninfo", "enabled", info_on)
SetTriggerOption("global_quest", "enabled", global_quest_on)
SetTriggerOption("remort_auction", "enabled", remort_auction_on)

function reset_aard()
   font_name = default_font_name
   font_size = default_font_size
   WindowPosition(win, default_x, default_y, 0, 18)
   WindowResize(win, default_width, default_height, WINDOW_BACKGROUND_COLOUR)
   Repaint() -- hack because WindowPosition doesn't immediately update coordinates
   SaveState()
   OnPluginInstall()
end

function ResizeMoveCallback ()
   if GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1" then
      return
   end
   posx, posy = WindowInfo(win, 17), WindowInfo(win, 18)
   width = width+posx-startx
   startx = posx
   if (WindowTextWidth(win, win_font, "WWWCOMMUNICATION")+2*SCROLL_BAR_WIDTH > width) then
      width = WindowTextWidth(win, win_font, "WWWCOMMUNICATION")+2*SCROLL_BAR_WIDTH
      startx = windowinfo.window_left+width
   elseif (windowinfo.window_left+width > GetInfo(281)) then
      width = GetInfo(281)-windowinfo.window_left
      startx = GetInfo(281)
   end
   height = height+posy-starty
   starty=posy
   if (3*SCROLL_BAR_WIDTH+10+line_height+TITLE_HEIGHT > height) then
      height = 3*SCROLL_BAR_WIDTH+10+line_height+TITLE_HEIGHT
      starty = windowinfo.window_top+height
   elseif (windowinfo.window_top+height > GetInfo(280)) then
      height = GetInfo(280)-windowinfo.window_top
      starty = GetInfo(280)
   end
   if (utils.timer() - lastRefresh > 0.0333) then
      init(false)
      lastRefresh = utils.timer()
   end
end

lastRefresh = 0

function ResizeReleaseCallback ()
   height = TITLE_HEIGHT+(line_height*(WINDOW_LINES-1))+3 -- snap height down to not have dead space after last line
   init(true) -- true here causes old lines to re-wrap at the new size
end

win = GetPluginID()
function OnPluginListChanged ()
   dofile "lua/aard_requirements.lua"
   -- let aard_chat_echo hide things
   CallPlugin ("55616ea13339bc68e963e1f8", "enable_hiding", true, GetPluginID())
end

function OnPluginInstall ()
   -- Dummy window to get font characteristics
   check(WindowCreate(win, 0, 0, 1, 1, 0, 0, WINDOW_BACKGROUND_COLOUR))

   local fonts = utils.getfontfamilies ()

   -- if not there already, add it
   if not fonts.Dina then
      AddFont(GetInfo (66) .. "\\Dina.fon")
      fonts = utils.getfontfamilies()
   end -- if Dina not installed

   if fonts["Dina"] then
      default_font_size = 8
      default_font_name = "Dina"
   elseif fonts ["Courier New"] then
      default_font_size = 9
      default_font_name = "Courier New" -- the actual font
   else
      default_font_size = 9
      default_font_name = "Lucida Console"
   end -- if

   font_name = GetVariable("font_name") or default_font_name
   font_size = tonumber(GetVariable("font_size")) or default_font_size

   header_font_name = font_name
   header_font_size = font_size

   win_font = "font"..win
   win_head_font = "fonthead"..win
   check(WindowFont(win, win_font, font_name, font_size))
   check(WindowFont(win, win_head_font, header_font_name, header_font_size))

   font_height = WindowFontInfo(win, win_font, 1) -  WindowFontInfo(win, win_font, 4) + 1
   header_font_height = WindowFontInfo(win, win_head_font, 1) - WindowFontInfo(win, win_head_font, 4) + 1
   TITLE_HEIGHT = header_font_height*1.8
   line_height = font_height+1

   -- install the window movement handler, get back the window position
   windowinfo  = movewindow.install(win, miniwin.pos_top_right, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=default_x, y=default_y})

   init(true)
   -- if disabled last time, stay disabled
   if GetVariable ("enabled") == "false" then
      ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
      check (EnablePlugin(GetPluginID (), false))
      return
   else
      OnPluginEnable()  -- do initialization stuff
   end-- they didn't enable us last time
end

function init (firstTime)
   -- how many lines and columns will fit?
   WINDOW_LINES = math.ceil((height-TITLE_HEIGHT)/line_height)

   if (firstTime == true) then
      WindowCreate(win, windowinfo.window_left, windowinfo.window_top, width, height, windowinfo.window_mode, windowinfo.window_flags, WINDOW_BACKGROUND_COLOUR)

      -- catch for right-click menu and line selection
      WindowAddHotspot(win, "textarea", 1, TITLE_HEIGHT, width-SCROLL_BAR_WIDTH-1,height-3, "", "", "MouseDown", "CancelMouseDown", "MouseUp", "", 2, 0)
      WindowDragHandler(win, "textarea", "TextareaMoveCallback", "TextareaReleaseCallback", 0x10)

      -- mouse wheel handler for scrolling up/down
      WindowScrollwheelHandler(win, "textarea", "wheel_move")

      -- add the drag handler so they can move the window around
      movewindow.add_drag_handler(win, 0, 0, 0, TITLE_HEIGHT)

      -- scroll bar up/down buttons
      WindowAddHotspot(win, "up", width-SCROLL_BAR_WIDTH, TITLE_HEIGHT, 0, TITLE_HEIGHT+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowAddHotspot(win, "down", width-SCROLL_BAR_WIDTH, height-(2*SCROLL_BAR_WIDTH), 0, height-SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)

      -- add the resize widget hotspot
      WindowAddHotspot(win, "resize", width-SCROLL_BAR_WIDTH, height-SCROLL_BAR_WIDTH, width, height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
      WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)

      -- re-wrap buffered lines at the new size
      lines = {}
      for _,styles in ipairs(rawlines) do
         fillBuffer(styles[1],styles[2])
      end
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win) -- fail silently
   else
      WindowResize(win, width, height, WINDOW_BACKGROUND_COLOUR)
      WindowMoveHotspot(win, "textarea", 0, TITLE_HEIGHT, width-SCROLL_BAR_WIDTH-1, height-3)
      WindowMoveHotspot(win, "up", width-SCROLL_BAR_WIDTH, TITLE_HEIGHT, 0, TITLE_HEIGHT+SCROLL_BAR_WIDTH)
      WindowMoveHotspot(win, "down", width-SCROLL_BAR_WIDTH, height-(2*SCROLL_BAR_WIDTH), 0, height-SCROLL_BAR_WIDTH)
      WindowMoveHotspot(win, "resize", width-SCROLL_BAR_WIDTH, height-SCROLL_BAR_WIDTH, width, 0)
   end
   WindowShow(win, true)

   lineStart = math.max(1, #lines-WINDOW_LINES+2)
   lineEnd = math.max(1, #lines)

   -- title rectangle
   header_width = WindowTextWidth(win, win_head_font, "Communication Log")
   WindowGradient(win, 1, 0, width, TITLE_HEIGHT, WINDOW_BACKGROUND_COLOUR, 0x444444, 2)
   WindowText(win, win_head_font, "Communication Log", (width-header_width)/2, ((TITLE_HEIGHT-header_font_height)/2)-1, width, TITLE_HEIGHT, 0xEEEEEE, false)
   WindowLine(win, 0, TITLE_HEIGHT-1, width, TITLE_HEIGHT-1, WINDOW_BORDER_COLOUR, 0 + 0x0200, 1)

   -- resize tag
   WindowRectOp(win, 2, width-SCROLL_BAR_WIDTH, height-SCROLL_BAR_WIDTH, 0, 0, SCROLL_BACKGROUND_COLOUR) -- resizer background
   WindowLine(win, width-SCROLL_BAR_WIDTH+1, height-2, width-2, height-SCROLL_BAR_WIDTH+1, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+2, height-2, width-2, height-SCROLL_BAR_WIDTH+2, 0x696969, 0, 1)
   WindowLine(win, width-SCROLL_BAR_WIDTH+4, height-2, width-2, height-SCROLL_BAR_WIDTH+4, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+5, height-2, width-2, height-SCROLL_BAR_WIDTH+5, 0x696969, 0, 1)
   WindowLine(win, width-SCROLL_BAR_WIDTH+7, height-2, width-2, height-SCROLL_BAR_WIDTH+7, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+8, height-2, width-2, height-SCROLL_BAR_WIDTH+8, 0x696969, 0, 1)
   WindowLine(win, width-SCROLL_BAR_WIDTH+10, height-2, width-2, height-SCROLL_BAR_WIDTH+10, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+11, height-2, width-2, height-SCROLL_BAR_WIDTH+11, 0x696969, 0, 1)

   -- draw border
   WindowRectOp(win, 1, 0, 0, 0, 0, WINDOW_BORDER_COLOUR)

   drawStuff()
end

function OnPluginConnect ()
   -- first time after connect, get tags right
end --  OnPluginConnect

function OnPluginClose ()
   -- if enabled
   if GetPluginInfo(GetPluginID(), 17) then
      OnPluginDisable()
   end -- if enabled
   WindowDelete(win)
end -- OnPluginClose

function OnPluginEnable ()
   WindowShow(win, true)
   -- if we are connected when the plugin loads, it must have been reloaded while playing
   if IsConnected() then
      OnPluginConnect()
   end -- if already connected
   SaveState()
end -- OnPluginEnable

require "serialize"
function OnPluginSaveState()
   -- save window current location for next time
   SetVariable("enabled", tostring (GetPluginInfo (GetPluginID(), 17)))
   movewindow.save_state(win)

   SetVariable("font_name", font_name)
   SetVariable("font_size", font_size)
   SetVariable("date_format", date_format)
   if WindowInfo(win, 3) and WindowInfo(win, 4) then
      width = WindowInfo(win, 3)
      height = WindowInfo(win, 4)
   end
   SetVariable("WINDOW_WIDTH", width)
   SetVariable("WINDOW_HEIGHT", height)
   SetVariable("info_on", info_on)
   SetVariable("global_quest_on", global_quest_on)
   SetVariable("remort_auction_on", remort_auction_on)
   SetVariable("warfare_on", warfare_on)
   SetVariable("log_to_file", log_to_file)
   SetVariable("log_colour_codes", log_colour_codes)
   SetVariable("log_timestamps", log_timestamps)
   SetVariable("show_donations", show_donations)
   SetVariable("channels_table", serialize.save("channels_table"))
end --  OnPluginSaveState

function OnPluginDisable()
   WindowShow( win, false )
   SaveState()
end --  OnPluginDisable

-- display one line
function Display_Line (line, styles, backfill_start, backfill_end)
   local left = TEXT_INSET
   local top = TITLE_HEIGHT+(line*line_height)
   if (backfill_start ~= nil and backfill_end ~= nil) then
      WindowRectOp(win, 2, backfill_start, top+1, backfill_end, top+line_height+1, 0x444444)
   end -- backfill
   if styles then
      for _, v in ipairs(styles) do
         local t = v.text
         -- now clean up dangling newlines that cause block characters to show
         if string.sub(v.text,-1) == "\n" then
            t = string.sub(v.text,1,-2)
         end
         left = left + WindowText(win, win_font, t, left, top,  width-SCROLL_BAR_WIDTH, 0, v.textcolour)
      end -- for each style run
   end
end -- Display_Line

-- Returns an array {start, end, text}
function findURLs(text)
   local URLs = {}
   local start, position = 0, 0
   -- "rex" is a table supplied by MUSHclient for PCRE functionality.
   local re = rex.new("(?:https?://|mailto:)\\S*[\\w/=@#\\-\\?]")
   re:gmatch(text,
      function (link, _)
         start, position = string.find(text, link, position, true)
         table.insert(URLs, {start=start, stop=position, text=link})
      end
   )
   return URLs
end -- function findURL

-- display all visible lines
hyperlinks = {}
function writeLines ()
   WindowRectOp(win, 2, 1, TITLE_HEIGHT, width-SCROLL_BAR_WIDTH, -1, WINDOW_BACKGROUND_COLOUR) -- clear
   local ax = nil
   local zx = nil
   local line_no_colors = ""
   if #lines >= 1 then
      for count = lineStart, lineEnd do
         ax = nil
         zx = nil
         line_no_colors = strip_colours(StylesToColours(lines[count][1]))

         -- create clickable links for urls
         for i,v in ipairs(lines[count][3]) do
            local left = TEXT_INSET+WindowTextWidth(win, win_font, string.sub(line_no_colors, 1, v.start-1))
            local right = left+WindowTextWidth(win, win_font, string.sub(line_no_colors, v.start-1, v.stop-1))
            local top = TITLE_HEIGHT+((count-lineStart)*line_height)-1
            local bottom = top+line_height+1
            local link_name = table.concat({v.text,"   ",count,v.start,v.stop})
            if not WindowHotspotInfo(win, link_name, 1) then
               hyperlinks[link_name] = v.text
               WindowAddHotspot(win, link_name, left, top, math.min(right, width-SCROLL_BAR_WIDTH-1), bottom, "MouseOverLink", "CancelMouseOverLink", "MouseDown", "CancelMouseDown", "MouseUp", "Right-click this URL if you want to open it:\n"..v.text, 1)
               WindowDragHandler(win, link_name, "TextareaMoveCallback", "TextareaReleaseCallback", 0x10)
               WindowScrollwheelHandler(win, link_name, "wheel_move")
            end
         end

         -- create highlighting parameters when text is selected
         if copy_start_line ~= nil and copy_end_line ~= nil and count >= copy_start_line and count <= copy_end_line then
            ax = (((count == copy_start_line) and math.min(start_copying_x, WindowTextWidth(win, win_font, line_no_colors)+TEXT_INSET)) or TEXT_INSET)
            -- end of highlight for this line
            zx = math.min(width-SCROLL_BAR_WIDTH,(((count == copy_end_line) and math.min(end_copying_x, WindowTextWidth(win, win_font, line_no_colors)+TEXT_INSET)) or WindowTextWidth(win, win_font, line_no_colors)+TEXT_INSET))
         end

         Display_Line( count-lineStart, lines[count][1], ax, zx )
      end
   end
   BroadcastPlugin(999, "repaint")
end

barPos = ""
barSize = ""
totalSteps = ""
function drawStuff ()

   -- Scrollbar base
   WindowRectOp(win, 2, width-SCROLL_BAR_WIDTH, TITLE_HEIGHT, width, -SCROLL_BAR_WIDTH, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, width-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+TITLE_HEIGHT+1, width-1, height-(2*SCROLL_BAR_WIDTH)-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle

   if (keepscrolling == "up") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), TITLE_HEIGHT, 0, TITLE_HEIGHT+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, TITLE_HEIGHT+9,(width-SCROLL_BAR_WIDTH)+7, TITLE_HEIGHT+5,(width-SCROLL_BAR_WIDTH)+11, TITLE_HEIGHT+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), TITLE_HEIGHT, width, TITLE_HEIGHT+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, TITLE_HEIGHT+9,(width-SCROLL_BAR_WIDTH)+7, TITLE_HEIGHT+5,(width-SCROLL_BAR_WIDTH)+11, TITLE_HEIGHT+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end

   if (keepscrolling == "down") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), height-(SCROLL_BAR_WIDTH*2), 0, height-SCROLL_BAR_WIDTH-1, 10,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, (height-SCROLL_BAR_WIDTH)-11,(width-SCROLL_BAR_WIDTH)+7, (height-SCROLL_BAR_WIDTH)-7, (width-SCROLL_BAR_WIDTH)+11,(height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), height-(SCROLL_BAR_WIDTH*2), width, height-SCROLL_BAR_WIDTH, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, (height-SCROLL_BAR_WIDTH)-11,(width-SCROLL_BAR_WIDTH)+7, (height-SCROLL_BAR_WIDTH)-7, (width-SCROLL_BAR_WIDTH)+11,(height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end

   -- The scrollbar position indicator
   totalSteps = #lines
   if (totalSteps <= WINDOW_LINES-1) then
      totalSteps = 1
   end
   SCROLL_BAR_HEIGHT = (height-(3*SCROLL_BAR_WIDTH)-TITLE_HEIGHT)
   if (not dragscrolling) then
      stepNum = lineStart-1
      barPos = SCROLL_BAR_WIDTH +TITLE_HEIGHT+ ((SCROLL_BAR_HEIGHT/totalSteps) * stepNum)
      barSize = (SCROLL_BAR_HEIGHT/math.max(WINDOW_LINES-1,totalSteps)) * (WINDOW_LINES-1)
      if barSize < 10 then
         barSize = 10
      end
      if barPos+barSize > SCROLL_BAR_WIDTH+TITLE_HEIGHT+SCROLL_BAR_HEIGHT then
         barPos = SCROLL_BAR_WIDTH+TITLE_HEIGHT+SCROLL_BAR_HEIGHT - barSize
      end
      WindowAddHotspot(win, "scroller", (width-SCROLL_BAR_WIDTH), barPos, width, barPos+barSize, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "scroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
   end
   WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), barPos, width, barPos+barSize, 5, 15 + 0x800) -- scrollbar position indicator

   -- reset hyperlinks if the text moves
   for k,v in pairs(hyperlinks) do
      WindowDeleteHotspot(win, k)
   end
   hyperlinks = {}

   writeLines()
end

function wheel_move (flags, hotspot_id)
   if bit.band(flags, 0x100) ~= 0 then
      if lineStart < #lines-WINDOW_LINES+2 then
         -- down
         lineStart = math.max(1, math.min(#lines-WINDOW_LINES+2, lineStart+3))
         lineEnd = math.min(#lines, lineStart+WINDOW_LINES-2)
         drawStuff()
      end
   elseif lineStart > 1 then
      -- up
      lineStart = math.max(1, lineStart-3)
      lineEnd = math.min(#lines, lineStart+WINDOW_LINES-2)
      drawStuff()
  end -- if
end -- wheel_move

function ScrollerMoveCallback(flags, hotspot_id)
   mouseposy = WindowInfo(win, 18)
   windowtop = WindowInfo(win, 2)
   barPos = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+TITLE_HEIGHT)
   if barPos > height-(SCROLL_BAR_WIDTH*2)-barSize then
      barPos = height-(SCROLL_BAR_WIDTH*2)-barSize
      lineStart = math.max(1,#lines-WINDOW_LINES+2)
      lineEnd = #lines
   else
      lineStart = math.max(1,math.floor((barPos-SCROLL_BAR_WIDTH-TITLE_HEIGHT)/(SCROLL_BAR_HEIGHT/totalSteps)+1))
      lineEnd = math.min(lineStart + WINDOW_LINES-2, #lines)
   end
   drawStuff()
end

function ScrollerReleaseCallback(flags, hotspot_id)
   dragscrolling = false
   drawStuff()
end

function add_line ( line, is_beginning_of_message, urls )
   -- add new line
   table.insert(lines, {[1]=line, [2]=is_beginning_of_message, [3]=urls} )
   -- advance the count
   if #lines >= WINDOW_LINES then
      lineStart = lineStart + 1
   end -- if

   if #lines > 1 then
      lineEnd = lineEnd + 1
   end -- if
end -- add_line

function fillBuffer(rawstyles, rawurls)
   local avail = width - (TEXT_INSET * 2) - 9
   local line_styles = {}
   local beginning = true
   local length = 0
   local styles = copytable.deep(rawstyles)
   local urls = copytable.deep(rawurls)

   -- It turns out you can reduce the function
   -- call time by instantiating functions as local.
   -- This is really just me being silly.
   local remove = table.remove
   local insert = table.insert

   -- Keep pulling out styles and trying to fit them on the current line
   while #styles > 0 do
      -- break off the next style
      local style = remove(styles, 1)

      -- make this handle forced newlines like in the flickoff social
      -- by splitting off and sticking the next part back into the
      -- styles list for the next pass
      foundbreak = false
      newline = string.find(style.text, "\n")
      if newline then
         insert(styles, 1, {text = string.sub(style.text,newline+1),
            length = style.length-newline+1,
            textcolour = style.textcolour,
            backcolour = style.backcolour}
         )
-- we're leaving in the newline characters here because we need to be
-- able to copy them later. I'll clean up the buggy visual later when
-- actually displaying the lines.
         style.length = newline
         style.text = string.sub(style.text,1,newline)
         foundbreak = true
      end

      local text_width = WindowTextWidth(win, win_font, style.text)

      -- if it fits, copy whole style in
      if text_width <= avail then
         insert(line_styles, style)
         length = length + style.length
         avail = avail - text_width
         if foundbreak then
            avail = 0
         end
      else -- otherwise, have to split style
         -- look for trailing space (work backwards). remember where space is
         local col = style.length - 1
         local split_col
         -- keep going until out of columns
         while col > 1 do
            text_width = WindowTextWidth(win, win_font, style.text:sub(1, col))
            if text_width <= avail then
               if not split_col then
                  split_col = col  -- in case no space found, this is where we can split
               end -- if
               -- see if space here
               if style.text:sub(col, col) == " " then
                  split_col = col
                  break
               end -- if space
            end -- if will now fit
            col = col - 1
         end -- while

         if split_col then
            -- if we found a place to split, use old style and truncate it.
            -- Also stick the rest back with the same styling back into the styles list
            insert(line_styles, style)
            local style_copy = copytable.shallow(style)
            style.text = style.text:sub(1, split_col)
            style.length = split_col
            style_copy.text = style_copy.text:sub(split_col + 1)
            style_copy.length = #style_copy.text
            insert(styles, 1, style_copy)
            length = length + style.length
         elseif next(line_styles) == nil then
         -- Actually, I don't think this can ever happen. -Fiendish
            insert(line_styles, style)
            length = length + style.length
         else
            -- if we're about to start a new style and the
            -- line is completely full, put it back in the list for later
            insert(styles, 1, style)
         end -- if
         avail = 0  -- now we need to wrap
      end -- if could/not fit whole thing in

      -- out of styles or out of room? add a line for what we have so far
      if #styles == 0 or avail <= 0 then
         if #lines >= MAX_LINES then
            -- if the history buffer is full then remove the oldest line
            remove(lines, 1)
            lineStart = lineStart - 1
            lineEnd = lineEnd - 1
         end -- buffer full

         local line_urls = {}
         while urls[1] and urls[1].stop <= length do
            insert(line_urls, remove(urls, 1))
         end
         if urls[1] and urls[1].start < length then
            local url = copytable.deep(urls[1])
            url.stop = length + 1
            urls[1].stop = urls[1].stop-1
            urls[1].old = true
            insert(line_urls, url)
         end
         for i,v in ipairs(urls) do
            urls[i].start = urls[i].start - length
            urls[i].stop = urls[i].stop - length
            if urls[i].start <= 1 then
               urls[i].start = 1
               urls[i].stop = urls[i].stop+1
            end
         end

         add_line( line_styles, beginning, line_urls )

         avail = width - (TEXT_INSET * 2) - 9
         line_styles = {}
         length = 0
         beginning = false
      end -- line full
   end -- while we still have styles over
end

function sanitize_filename(str)
   str = string.gsub(str, "[^%w%s()_-]", "")
   return Trim(str)
end

function stampAndStore(styles)
   local text = ""
   local log_text = ""

   -- remove most control characters, but preserve newlines
   for i,v in ipairs(styles) do
      v.text = v.text:gsub("[^%g%s\n]","")
      v.length = v.text:len()
   end

   timestamp = os.date(date_format)

   text = StylesToColours(styles)
   local urls = findURLs(strip_colours(timestamp..text))

   if (log_to_file == 1) then
      if (log_timestamps == 1) then
         log_text = "@w"..timestamp..text
      else
         log_text = text
      end
      if (log_colour_codes == 0) then
         log_text = strip_colours(log_text)
      end
      local filename = GetInfo(58):gsub("^.\\",GetInfo(56))..sanitize_filename(GetInfo(2)).."ChatLog.txt"
      local f, err = io.open (filename, "a+") -- handle to chat log file
      if f then
         f:write(log_text.."\n") -- write to it
         f:close()  -- close that file now
      else
         ColourNote("white", "red", "COMMUNICATION LOG ERROR: Failed to access your logging file because of the following reason:" )
         ColourNote("white", "red", err)
         ColourNote("white", "red", "Fix the problem or disable Logging to File in the Communication Log plugin.")
      end
   end

   table.insert(styles,1,{text=timestamp, length=string.len(timestamp), textcolour=0xc0c0c0})

   -- store the raw lines for use during resizing
   if #rawlines >= MAX_LINES then
      table.remove(rawlines, 1)
   end
   table.insert(rawlines, {[1]=styles, [2]=urls})

   fillBuffer(styles, urls)
   drawStuff()
end

-- Takes input as a string with embedded Aardwolf color codes. Use via CallPlugin().
-- See:   http://mushclient.com/scripts/doc.php?function=CallPlugin
-- You can use the function StylesToColours(styles_table) from aardwolf_colors.lua
-- or manually embed your own colors to push any colorized line you want to the log window.
-- Example: CallPlugin("b555825a4a5700c35fa80780","storeFromOutside","HELLO@RHello@Mhello@x215hello@x66HELLO")
function storeFromOutside(msg)
   stampAndStore(ColoursToStyles(msg))
end

-- stolen from Mendaloth
function rsocial (name, line, wildcards, styles)
	-- Remote socials will always start with a dark cyan or bright magenta *
	-- Checking color cuts down on non-socials ending up in the chat log...
	if (styles[1].textcolour == GetNormalColour(7) or styles[1].textcolour == GetBoldColour(6)) then
		stampAndStore(filter_as_needed(styles))
	end
end

function untagged_info (name, line, wildcards, styles)
   local result = filter_as_needed(styles)
   if result then
      stampAndStore(result)
   end
end -- untagged info

function filter_as_needed(msg)
   if GetPluginInfo("48f867c18f6ff1d6d3b52918", 17) then -- if using the #sub plugin
      if type(msg) == "table" then
         msg = StylesToColours(msg)
      end
      rc, msg = CallPlugin("48f867c18f6ff1d6d3b52918", "filter_string", msg)
   end
   if type(msg) == "string" then
      return ColoursToStyles(msg)
   else
      return msg
   end
end

function OnPluginBroadcast (msg, id, name, text)
   -- Look for GMCP handler.
   if (id == '3e7dedbe37e44942dd46d264') then
      if (text == "comm.channel") then
         gmcpcomm = gmcp("comm.channel")
         msg = gmcpcomm.msg or ""
         chan = gmcpcomm.chan or ""
         if (show_donations == 1 or string.match(strip_colours(msg), "^CLAN ANNOUNCEMENT: %a+ has donated") == nil) then
            if not channels_table[chan] then
               addNewChannel(chan)
            end
            if channels_table[chan]["capture"] then
               local result = filter_as_needed(msg)
               if result then
                  stampAndStore(result)
               end
            end
         end
      end
   elseif (id == "462b665ecb569efbf261422f" and msg==996 and text == "re-register z") then
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win)
   end
end

keepscrolling = ""
require "wait"

function scrollbar()
   wait.make(
   function()
      while keepscrolling == "up" or keepscrolling == "down" do
         if keepscrolling == "up" then
            if (lineStart > 1) then
               lineStart = lineStart - 1
               lineEnd = lineEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "down" then
            if (lineEnd < #lines) then
               lineStart = lineStart + 1
               lineEnd = lineEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         drawStuff()
      end
   end
   )
end

function GetAllBufferedMessages()
   local t = {}
   for _,styles in ipairs(rawlines) do
      table.insert(t, StylesToColours(styles[1]))
   end
   SetClipboard(table.concat(t,"\n"))
end

function MouseOver(flags, hotspot_id)
   keepscrolling = ""
end

function CancelMouseOver(flags, hotspot_id)
   keepscrolling = ""
end

function MouseOverLink(flags, hotspot_id)
   local url = string.gsub(hotspot_id, "(.*   ).*", "%1")
   local hotspots = WindowHotspotList(win)
   for _, v in ipairs (hotspots) do
      if string.find(v, url, 1, true) then
         local left = WindowHotspotInfo(win, v, 1)
         local right = WindowHotspotInfo(win, v, 3)
         local bottom = WindowHotspotInfo(win, v, 4)
         WindowLine(win, left, bottom, right, bottom, 0xffffff, 256, 1);
      end
   end
   BroadcastPlugin(999, "repaint")
end

function CancelMouseOverLink(flags, hotspot_id)
   local url = string.gsub(hotspot_id, "(.*   ).*", "%1")
   if not string.find(WindowInfo(win, 19), url, 1, true) then
      writeLines()
   end
end

temp_start_copying_x = 0
start_copying_y = 0
copied_text = ""
function MouseDown(flags, hotspot_id)
   if (hotspot_id == "resize") then
      startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
   elseif (hotspot_id == "scroller") then
      clickdelta = WindowHotspotInfo(win, "scroller", 2)-WindowInfo (win, 15)
      dragscrolling = true
   elseif (hotspot_id == "up" or hotspot_id == "down") then
      keepscrolling = hotspot_id
      scrollbar()
   elseif (flags == 0x10) then
      temp_start_copying_x = WindowInfo(win, 14)
      start_copying_y = WindowInfo(win, 15)
      copy_start_windowline = math.floor((start_copying_y-TITLE_HEIGHT)/line_height)
      temp_start_line = copy_start_windowline+lineStart
      copied_text = ""
      copy_start_line = nil
      copy_end_line = nil
      writeLines()
   end
end

function CancelMouseDown(flags, hotspot_id)
   keepscrolling = ""
   drawStuff()
end

end_copying_x = 0
end_copying_y = 0
function MouseUp(flags, hotspot_id)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu(hotspot_id)
   else
      drawStuff()
   end
   keepscrolling = ""
   return true
end

function TextareaMoveCallback(flags, hotspot_id)
   if bit.band (flags, miniwin.hotspot_got_lh_mouse) ~= 0 then -- only on left mouse button
      copied_text = ""
      end_copying_x = WindowInfo(win, 17)-WindowInfo(win, 1)
      end_copying_y = WindowInfo(win, 18)-WindowInfo(win, 2)
      local ypos = end_copying_y
      end_copying_x = math.max(TEXT_INSET,math.min(end_copying_x, width-SCROLL_BAR_WIDTH))
      end_copying_y = math.max(TITLE_HEIGHT+1,math.min(end_copying_y, TITLE_HEIGHT-1+(line_height*(WINDOW_LINES-1))))
      copy_end_windowline = math.floor((end_copying_y-TITLE_HEIGHT)/line_height)
      copy_end_line = copy_end_windowline+lineStart
      copy_start_line = temp_start_line
      start_copying_x = temp_start_copying_x

      if not copy_start_line then
         -- OS bug causing errors for me. hack around stupid mouse click tracking mess
         return
      end

      if (copy_start_line > #lines) then
         start_copying_x = width-SCROLL_BAR_WIDTH
      end

      -- the user is selecting backwards, so reverse the start/end orders
      if copy_end_line < temp_start_line then
         local temp = copy_end_line
         copy_end_line = copy_start_line
         copy_start_line = temp
         temp = end_copying_x
         end_copying_x = start_copying_x
         start_copying_x = temp
      end -- if
      if copy_end_line == copy_start_line and end_copying_x < start_copying_x then
         local temp = end_copying_x
         end_copying_x = start_copying_x
         start_copying_x = temp
      end -- if

      for copy_line=copy_start_line,copy_end_line do
         if (lines[copy_line] ~= nil) then
            local startpos = 1
            local endpos = 99999
            if (copy_line-lineStart+1 > 0 and copy_line-lineStart < WINDOW_LINES and copy_line-lineStart < #lines) then
               -- snap to character boundaries instead of selecting arbitrary pixel widths
               local line_no_colors = strip_colours(StylesToColours(lines[copy_line][1]))
               startpos = 1
               endpos = #line_no_colors
               -- special deal for the first line
               if copy_line == copy_start_line then
                  for pos=1,#line_no_colors do
                     startpos = pos
                     if WindowTextWidth(win, win_font, string.sub(line_no_colors,1,pos)) > start_copying_x then
                        start_copying_x = WindowTextWidth(win, win_font, string.sub(line_no_colors,1,pos-1))+TEXT_INSET
                        break
                     end
                  end
               end
               -- special deal for the last line
               if copy_line == copy_end_line then
                  local found = false
                  endpos = 0
                  for pos=1,#line_no_colors do
                     if WindowTextWidth(win, win_font, string.sub(line_no_colors,1,pos)) > end_copying_x then
                        end_copying_x = WindowTextWidth(win, win_font, string.sub(line_no_colors,1,endpos))+TEXT_INSET
                        found = true
                        break
                     end
                     endpos = pos
                  end
               end
            end -- if should show highlight

            -- store selected area for later
            copied_part = StylesToColours(TruncateStyles(lines[copy_line][1], startpos, endpos))
            if copy_line ~= copy_end_line and copy_line ~= #lines and lines[copy_line+1][2] == true then
               -- only put a line break if the next line is from a different message
               copied_part = copied_part.."@w\n"
            elseif copy_line == copy_end_line or copy_line == #lines then
               -- tack a white code on to the very end
               copied_part = copied_part.."@w"
            end
            copied_text = copied_text..(((copied_part ~= nil) and copied_part) or "")
         end -- if valid line
      end -- for

      if ypos < TITLE_HEIGHT then
         keepscrolling = "up"
         scrollbar()
      elseif ypos > height then
         keepscrolling = "down"
         scrollbar()
      else
         keepscrolling = ""
         writeLines()
      end
   end -- if left mouse button
end -- function TextareaMoveCallback

function TextareaReleaseCallback(flags, hotspot_id)
   copy_start_line = math.min(#lines, copy_start_line or 0)
   copy_end_line = math.min(#lines, copy_end_line or 0)
end

function LeftClickOnly(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      return true
   end
   return false
end

function chat_show (name, line, wildcards)
   WindowShow( win, true )
   ColourNote ("yellow", "", "Chats window now shown. Type 'chats hide' to hide it.")
end -- function chat_show

function chat_hide (name, line, wildcards)
   WindowShow( win, false )
   ColourNote ("yellow", "", "Chats window now hidden. Type 'chats show' to see it again.")
end -- function chat_hide

require "pairsbykeys"

local init_channel_names = {"advice","answer","auction","barter","claninfo","clantalk","curse","debate","dtell","ftalk","gametalk","gclan","gossip","gratz","gsocial","gtell","helper","immtalk","lasertag","ltalk","market","mobsay","music","mxit","newbie","nobletalk","pchat","pokerinfo","ptell","question","quote","racetalk","rauction","rp","say","sports","spouse","tech","tell","tiertalk","trivia","wangrp","wardrums"}
channels_table = {}
loadstring(GetVariable("channels_table") or "")()

function addNewChannel(name)
   if not channels_table[name] then
      channels_table[name] = {capture=true}
   end
end

function constructDefaultChannels()
   for i,v in ipairs(init_channel_names) do
      addNewChannel(v)
   end
end

constructDefaultChannels()

-- right click menu
function right_click_menu (hotspot_id)
   hotspots = {scroller=true, resize=true, down=true, up=true, textarea=true}
   menustring ="!"
   local hyperlink_skip = 0
   local echo_skip = 0
   local url = ""
   if (WindowInfo(win, 15) > TITLE_HEIGHT) and not hotspots[hotspot_id] then
      hyperlink_skip = 2
      menustring = menustring.."Go to URL: "..hyperlinks[hotspot_id].."|Copy URL to Clipboard|-|"
      url = hyperlinks[hotspot_id]
   end
   menustring = menustring.."Copy Selected Without Colors|Copy Selected|Copy All|-|Change Font"
   menustring = menustring .. "|>Timestamp|"..((date_format=="" and "+") or "").."No Timestamps|"..((date_format=="[%d %b %H:%M:%S] " and "+") or "").."30 Aug 13:29:49|"..((date_format=="[%d %b %I:%M:%S%p] " and "+") or "").."30 Aug 01:20:12PM|"..((date_format=="[%H:%M:%S] " and "+") or "").."13:29:08|"..((date_format=="[%I:%M:%S%p] " and "+") or "").."1:22:06 PM|<"

   menustring = menustring .. "|Customize Channels"
   menustring = menustring .. "|>Capture Other Info|"..((info_on==1 and "+") or "").."INFO:|"..((global_quest_on==1 and "+") or "").."Global Quest:|"..((remort_auction_on==1 and "+") or "").."Remort Auction:|"..((show_donations==1 and "+") or "").."Clan Donations|"..((warfare_on==1 and "+") or "").."WARFARE:|".."<|-"

   if (IsPluginInstalled("55616ea13339bc68e963e1f8")) then
      err,info_echo,global_quest_echo,remort_auction_echo,donations_echo,warfare_echo = CallPlugin("55616ea13339bc68e963e1f8", "getEchos")
      menustring = menustring .. "|>Echo Channels In Main Window|Echo All|Echo None|Custom Echo List|-|>Echo Other Info|"..((info_echo and "+") or "").."INFO:|"..((global_quest_echo and "+") or "").."Global Quest:|"..((remort_auction_echo and "+") or "").."Remort Auction:|"..((donations_echo and "+") or "").."Clan Donations|"..((warfare_echo and "+") or "").."WARFARE:|".."<|<"
      echo_skip = 8
   end

   menustring = menustring .. "|>Logging To File|"..((log_to_file==1 and "Disable|") or "Enable|")..((log_colour_codes==0 and "+") or "").."Remove Color Codes|"..((log_timestamps==0 and "+") or "").."Remove Timestamps|<|-|Bring To Front|Send To Back"
   result = WindowMenu (win,
      WindowInfo (win, 14),  -- x position
      WindowInfo (win, 15),   -- y position
      menustring) -- content
   if result ~= "" then
      numResult = tonumber(result)
      if numResult == hyperlink_skip-1 then
         local res = OpenBrowser(url)
         if res ~= 0 then
            SetClipboard(url)
            ColourNote("yellow", "red", "MUSHclient may have encountered an error trying to open the selected URL. It has been copied to the clipboard.")
            ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
            ColourNote("yellow","",url)
            ColourNote("cyan","","^---------------------------------------------------------^")
         end
      elseif numResult == hyperlink_skip then
         SetClipboard(url)
         ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
         ColourNote("yellow","",url)
         ColourNote("cyan","","^---------------------------------------------------------^")
      elseif numResult == 1+hyperlink_skip then
         if #copied_text > 0 then
            local declored_text = strip_colours(copied_text)
            SetClipboard(declored_text)
            ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
            ColourNote("yellow","",declored_text)
            ColourNote("cyan","","^---------------------------------------------------------^")
         end
      elseif numResult == 2+hyperlink_skip then
         if #copied_text > 0 then
            SetClipboard(copied_text)
            ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
            ColourNote("yellow","",copied_text)
            ColourNote("cyan","","^---------------------------------------------------------^")
         end
      elseif numResult == 3+hyperlink_skip then
         GetAllBufferedMessages()
         ColourNote ("yellow", "", "All chat messages copied to clipboard.")
      elseif numResult == 4+hyperlink_skip then
         wanted_font = utils.fontpicker (font_name, font_size) --font dialog
         if wanted_font then
            font_name = wanted_font.name
            font_size = wanted_font.size
            SetVariable ("font_name", font_name)
            SetVariable ("font_size", font_size)
            OnPluginInstall()
         end
      elseif numResult == 5+hyperlink_skip then
         date_format = ""
         ColourNote ("yellow", "", "Timestamps in communication window DISABLED.")
      elseif numResult == 6+hyperlink_skip then
         date_format = "[%d %b %H:%M:%S] "
         ColourNote ("yellow", "", "Timestamps in communication window ENABLED using format like '30 Aug 13:29:49'.")
      elseif numResult == 7+hyperlink_skip then
         date_format = "[%d %b %I:%M:%S%p] "
         ColourNote ("yellow", "", "Timestamps in communication window ENABLED using format like '30 Aug 01:20:12PM'.")
      elseif numResult == 8+hyperlink_skip then
         date_format = "[%H:%M:%S] "
         ColourNote ("yellow", "", "Timestamps in communication window ENABLED using format like '13:29:08'.")
      elseif numResult == 9+hyperlink_skip then
         date_format = "[%I:%M:%S%p] "
         ColourNote ("yellow", "", "Timestamps in communication window ENABLED using format like '1:22:06 PM'.")
      elseif numResult == 10+hyperlink_skip then
         local tbl = {}
         local defaults = {}
         local i = 1
         for k,v in pairsByKeys(channels_table) do
            tbl[i] = k
            defaults[i] = v["capture"]
            i = i+1
         end
         local capture_result = utils.multilistbox ("Choose which channels to capture to this communication log window.", "Communication Log Channel Selection", tbl, defaults)
         if capture_result and next(capture_result) then -- cancel if the list is empty
            for i,v in ipairs(tbl) do
               channels_table[v]["capture"] = capture_result[i]
            end
         end
      elseif numResult == 11+hyperlink_skip then
         if info_on == 0 then
            ColourNote ("yellow", "", "INFO capturing is now ENABLED.")
         else
            ColourNote ("yellow", "", "INFO capturing is now DISABLED.")
         end
         EnableTrigger("info", 0 == info_on)
         EnableTrigger("raidinfo", 0 == info_on)
         EnableTrigger("claninfo", 0 == info_on)
         info_on = GetTriggerOption("info","enabled")
      elseif numResult == 12+hyperlink_skip then
         if global_quest_on == 0 then
            ColourNote ("yellow", "", "Global Quest capturing is now ENABLED.")
         else
            ColourNote ("yellow", "", "Global Quest capturing is now DISABLED.")
         end
         EnableTrigger("global_quest", 0 == global_quest_on)
         global_quest_on = GetTriggerOption("global_quest","enabled")
      elseif numResult == 13+hyperlink_skip then
         if remort_auction_on == 0 then
            ColourNote ("yellow", "", "Remort Auction capturing is now ENABLED.")
         else
            ColourNote ("yellow", "", "Remort Auction capturing is now DISABLED.")
         end
         EnableTrigger("remort_auction", 0 == remort_auction_on)
         remort_auction_on = GetTriggerOption("remort_auction","enabled")
      elseif numResult == 14+hyperlink_skip then
         if show_donations == 0 then
            ColourNote ("yellow", "", "Clan donation capturing is now ENABLED.")
         else
            ColourNote ("yellow", "", "Clan donation capturing is now DISABLED.")
         end
         show_donations = (((0 == show_donations) and 1) or 0)
         SetVariable("show_donations", show_donations)
      elseif numResult == 15+hyperlink_skip then
         if warfare_on == 0 then
            ColourNote ("yellow", "", "Warfare capturing is now ENABLED.")
         else
            ColourNote ("yellow", "", "Warfare capturing is now DISABLED.")
         end
         EnableTrigger("warfare", 0 == warfare_on)
         warfare_on = GetTriggerOption("warfare","enabled")
      end

      if echo_skip ~= 0 then
         if numResult == 16+hyperlink_skip then
            CallPlugin("55616ea13339bc68e963e1f8", "chat_echo", "on")
         elseif numResult == 16+hyperlink_skip+1 then
            CallPlugin("55616ea13339bc68e963e1f8", "chat_echo", "off")
         elseif numResult == 16+hyperlink_skip+2 then
            CallPlugin("55616ea13339bc68e963e1f8", "chat_echo", "custom")
         elseif numResult == 16+hyperlink_skip+3 then
            CallPlugin("55616ea13339bc68e963e1f8", "hideEchos", info_echo, nil, nil, nil, nil)
         elseif numResult == 16+hyperlink_skip+4 then
            CallPlugin("55616ea13339bc68e963e1f8", "hideEchos", nil, global_quest_echo, nil, nil, nil)
         elseif numResult == 16+hyperlink_skip+5 then
            CallPlugin("55616ea13339bc68e963e1f8", "hideEchos", nil, nil, remort_auction_echo, nil, nil)
         elseif numResult == 16+hyperlink_skip+6 then
            CallPlugin("55616ea13339bc68e963e1f8", "hideEchos", nil, nil, nil, donations_echo, nil)
         elseif numResult == 16+hyperlink_skip+7 then
            CallPlugin("55616ea13339bc68e963e1f8", "hideEchos", nil, nil, nil, nil, warfare_echo)
         end
      end

      if numResult == 16+hyperlink_skip+echo_skip then
         log_to_file = (((0 == log_to_file) and 1) or 0)
         SetVariable("log_to_file", log_to_file)
         if log_to_file == 0 then
            ColourNote ("yellow", "", "Logging to file is now DISABLED.")
         else
            ColourNote ("yellow", "", "Logging to file is now ENABLED.")
         end
      elseif numResult == 17+hyperlink_skip+echo_skip then
         log_colour_codes = (((0 == log_colour_codes) and 1) or 0)
         SetVariable("log_colour_codes", log_colour_codes)
         if log_colour_codes == 0 then
            ColourNote ("yellow", "", "Color codes will be stripped from the log file.")
         else
            ColourNote ("yellow", "", "Color codes will be included in the log file.")
         end
      elseif numResult == 18+hyperlink_skip+echo_skip then
         log_timestamps = (((0 == log_timestamps) and 1) or 0)
         SetVariable("log_timestamps", log_timestamps)
         if log_timestamps == 0 then
            ColourNote ("yellow", "", "Timestamps will not be included in the log file.")
         else
            ColourNote ("yellow", "", "Timestamps will be included in the log file.")
         end
      elseif numResult == 19+hyperlink_skip+echo_skip then
         CallPlugin("462b665ecb569efbf261422f","boostMe", win)
      elseif numResult == 20+hyperlink_skip+echo_skip then
         CallPlugin("462b665ecb569efbf261422f","dropMe", win)
      end
      SaveState()
   end
end -- right_click_menu

function getmemoryusage()
  collectgarbage('collect')
  return collectgarbage('count')
end

]]>
</script>
</muclient>
