<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, August 02, 2010, 2:17 PM -->
<!-- MuClient version 4.51 -->
<!-- Plugin "GMCPHandler" generated by Plugin Wizard -->

<muclient>

<plugin
   name="GMCP_handler"
   author="Lasher"
   id="3e7dedbe37e44942dd46d264"
   language="Lua"
   purpose="Handle GMCP messages and broadcast data"
   save_state="y"
   date_written="2010-08-02 14:16:26"
   requires="4.59"
   version="1.0"
>
<description trim="y">

Aardwolf GMCP Handler.

Purpose is to receive incoming GMCP messages and populate the global
table 'gmcpdata' with the values as received so that GMCP under Mushclient
can use partial refreshes of data. For example, we might receive:

   char.vitals { "hp": 100000, "mana": 90000, "moves": 41599 }

Then next time, if only HP and Mana have changed, receive:

   char.vitals { "hp": 100000, "mana": 85000 }

The previous value for 'moves' will be remembered and available until
it is refreshed. 

For full details on GMCP in Aardwolf see:

   http://www.aardwolf.com/wiki/index.php/Clients/GMCP

For Mushclient specific GMCP information including details on how to
use this plugin, see:

   http://www.aardwolf.com/wiki/index.php/Clients/MushclientGMCP

** DISCLAIMER ** 
================
I am not a lua expert. If you look at this code and think 'Wtf why did you do {X} when {Y} would have been so much easier', or '{Y} would 
have been a better lua idiom', please do let me know at wolf@aardwolf.com - thanks!

</description>

</plugin>

<aliases>
<alias
   script="gmcpdebug"
   match="^gmcpdebug (.*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   match="sendgmcp *"
   script="GMCP_Alias"
   enabled="y"
   send_to="12"
   sequence="100"
></alias>

</aliases>

<!--  Get our standard constants -->

<script>
<![CDATA[

require "json"
require "serialize"
require "gmcphelper"

local IAC, SB, SE, DO = 0xFF, 0xFA, 0xF0, 0xFD
local GMCP      = 201
local GMCPDebug = tonumber(GetVariable("GMCPDebug")) or 0

function gmcpdebug(name, line, wildcards)
   newval = tonumber(wildcards[1])
   if not newval or newval > 2 or newval < 0 then
      ColourNote("darkorange", "", "GMCPDebug valid values are: 0 - off, 1 - simple, 2 - verbose")
      return
   end
   GMCPDebug = newval
   local msg = "off"
   if GMCPDebug == 1 then
      msg = "simple"
   elseif GMCPDebug == 2 then
      msg = "verbose"
   end
   ColourNote ("darkorange", "", "GMCPDebug: " .. msg)
end

function GMCP_Alias(name, line, wildcards)
   if (wildcards[1] ~= nil) then
      Send_GMCP_Packet(wildcards[1]) -- in gmcphelper
   end
end 
 
---------------------------------------------------------------------------------------------------
-- Mushclient callback function when telnet SB data received.
---------------------------------------------------------------------------------------------------
function OnPluginTelnetSubnegotiation (msg_type, data)
   if msg_type ~= GMCP then
      return
   end -- if not GMCP
  
   if GMCPDebug > 0 then ColourNote ("darkorange", "", data) end

   message, params = string.match (data, "([%a.]+)%s+(.*)")
  
   if not message then
      return
   end -- if
  
   if not string.match (params, "^[%[{]") then
      params =  "[" .. params .. "]"  -- JSON hack, make msg first element of an array.
   end -- if 
   local succ,t = pcall(json.decode,params)

   if succ and type(t) == "table" then
      gmcpdata = gmcpdata or {}

      -- Create the higher level tables based on tag such as char.vitals or room.info etc.
      -- Lowest level of those will be the 'parent' for parse_gmcp
      local parent = gmcpdata
      for item in string.gmatch(message,"%a+") do

         -- reset data hacks
         if (item == "room" and message:sub(1,13) ~= "room.wrongdir") -- don't let room.wrongdir erase current room info
         or item == "comm" or item == "group" then 
            parent[item] = nil 
         end

         parent[item] = parent[item] or {}
         parent = parent[item]
      end
 
      parse_gmcp(t,nil,parent)

      if GMCPDebug > 1 then 
         print ("gmcpdata serialized: " .. serialize.save_simple(gmcpdata)) 
      end
 
      BroadcastPlugin(1,message)

      -- Examples of use from here on. Can be uncommented for debug.
      --print("Testing room.info.exits table      : " .. gmcpval("room.info.exits")) -- serialized table.
      --print("Testing correct room name          : " .. gmcpval("room.info.brief")) -- single field
      --print("Testing character str stat         : " .. gmcpval("char.stats.str"))  -- single number.
      --print("Testing top-level value            : " .. gmcpval("char"))            -- all char table.
      --print("Testing bad top-level value        : " .. gmcpval("sdlkfsldf"))       -- nil (not error)
      --print("Testing bad lower level            : " .. gmcpval("blah.1.2.3"))      -- nil
      --print("Testing bad lower level inside good: " .. gmcpval("room.info.hinick")) -- nil
      --print("Testing north exit, deeper nest    : " .. gmcpval("room.info.exits.n"))
      -- End of test cases.
 
  else
      ColourNote("white","red","GMCP DATA ERROR: "..t)
  end  -- if
   
end -- function OnPluginTelnetSubnegotiation

function OnPluginInstall()
   BroadcastPlugin(1,"reload") -- reload basically tells other plugins "clear all your gmcp data"
   if IsConnected() then
      -- pretend like we just logged in
      OnPluginConnect()
   end
end

function OnPluginSaveState()
   SetVariable("GMCPDebug", GMCPDebug)
end

function OnPluginConnect()
   Send_GMCP_Packet("request char")
   Send_GMCP_Packet("request room")
   Send_GMCP_Packet("request area")
   Send_GMCP_Packet("request quest")
   Send_GMCP_Packet("request group")
end

function OnPluginTelnetRequest (msg_type, data)
   if msg_type == GMCP and data == "WILL" then
      return true
   end -- if
  
   if msg_type == GMCP and data == "SENT_DO" then
      Note ("Enabling GMCP.") 
      -- This hard-coded block may need to be made into a config table as we add more message types.
      Send_GMCP_Packet (string.format ('Core.Hello { "client": "MUSHclient", "version": "%s" }', Version().." "..PackageVersion()))
      Send_GMCP_Packet ('Core.Supports.Set [ "Char 1", "Comm 1", "Room 1" ]')
      return true
   end -- if GMCP login needed (just sent DO)

   return false
end -- function OnPluginTelnetRequest

function PackageVersion()
   local ret = "unknown"
   -- borrowed from the package update checker
   version_file,err = io.open ("AardwolfPackageChanges.txt", "r")
   if version_file then -- the file exists
      --- read the snapshot revision from the third line
      line = version_file:read ("*l") -- read one line
      line = version_file:read ("*l") -- read one line
      line = version_file:read ("*l") -- read one line
      if line then -- if we got something
         ret = string.match(line, "(r%d+)") or "unknown"
      end
   end
   return ret
end

---------------------------------------------------------------------------------------------------
-- FUNCTION:: init_gmcpdata
--    Performs 2 functions:
--       1. Define a table of tags we support, including refreshed tags (clear each time) and 
--          regular tags.
--       2. Initialize gmcpdata to have empty tables nested at these levels.
---------------------------------------------------------------------------------------------------
function init_gmcpdata()
   -- Not used yet, placeholder to replace room reset data hack with a table.
end -- init_gmcpdata

---------------------------------------------------------------------------------------------------
-- FUNCTION:: parse_gmcp
--   Receives a set of JSON data and a parent to store its table into. Will recursively call 
--   itself building up the levels of, for example, gmcpdata.room.info.exits.n as it goes.
---------------------------------------------------------------------------------------------------
function parse_gmcp(t, done, parent) 

   assert (t, "nil table passed to parse_gmcp")
   assert (parent, "nil parent passed to parse_gmcp")
   assert (type (t) == "table",  "non-table value passed to parse_gmcp")
   assert (type (parent) == "table", "non-table parent value passed to parse_gmcp")

   local function parseone(val)
      if type (val) == "string" then
         return val 
      elseif type(val) == "function" then
         return nil
      else
         return tostring (val)
      end
   end -- parseone

   done = done or {}

   for key, value in pairs (t) do

      if type (value) == "table" and not done [value] then
         parent[key] = parent[key] or { }       
         done [value] = true
         parse_gmcp(value, done, parent[key])
      else
         parent[key] = parseone(value) -- might be able to remove last parameter.
      end
   end -- for
end -- parse_gmcp function

function OnPluginDisable()
   EnablePlugin(GetPluginID(), true)
   ColourNote("white", "blue", "You are not allowed to disable the "..
   GetPluginInfo(GetPluginID(), 1).." plugin. It is necessary for other plugins.")
end

function getmemoryusage()
  collectgarbage('collect')
  return collectgarbage('count')
end

]]>
</script>
</muclient>
