<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Save on Wednesday, September 01, 2010, 4:37 PM -->
<!-- MuClient version 4.59 -->

<!DOCTYPE muclient [
   <!ENTITY show_timing "false" > 
   <!ENTITY show_database_mods "false" > 
   <!ENTITY show_up_down "false" >
]>

<muclient>
<plugin
   name="Aardwolf_GMCP_Mapper"
   author="Multiple"
   id="b6eae87ccedd84f510b74714"
   language="Lua"
   purpose="Draws GMCP map for Aardwolf"
   date_written="2010-09-01 16:37:14"
   requires="4.73"
   version="2.0"
   save_state="y"
   >

<description trim="y">
<![CDATA[
AUTOMATIC MAPPER by Fiendish
** This is a very improved GMCP version of the original ATCP mapper by Nick Gammon.
** Some GMCP specific code added by Lasher.
** A few features contributed by Spartacus.
** Many major improvements made to Nick's original design by Fiendish.

The window can be dragged to a new location by dragging the room name.
LH-click on a room to speedwalk to it. RH-click on a room for options.

LH-click on the "*" button on the upper-left corner for configuration settings.
(click again on the [x] to close configuration)
]]>
</description>
</plugin>

<!--  Timers  -->

<timers>
<timer 
   name="backup_timer"
   enabled="y"
   script="automatic_backup" 
   hour="23" minute="59" second="59"
   active_closed="y" >
</timer>
</timers>

<aliases>

<alias
   match="mapper showroom *"
   enabled="y"
   script="draw_other"
   sequence="100"
></alias>

<alias
   match="mapper backup"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="manual_backup"
></alias>

<alias
   match="mapper backups*"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   send_to="12"
>
<send>
   if "%1" == " off" then
      SetVariable("backup_timer_enabled", "0")
      toggleBackups(false)
   elseif "%1" == " on" then
      SetVariable("backup_timer_enabled", "1")
      toggleBackups(true)
   elseif "%1" == "" then
      Note("Automated map database backup is currently "..((GetTimerInfo("backup_timer", 6) and "on") or ("off"..(GetVariable("backup_timer_enabled")=="1" and " but it will turn on as soon as you connect to the game" or "")))..".")
      local will_be_would_be = ((GetTimerInfo("backup_timer", 6) and "will be") or "would be (if enabled)")
      local seconds = GetTimerInfo("backup_timer", 13)
      local hours = math.floor(seconds/3600)
      seconds = seconds - hours*3600
      local minutes = math.floor(seconds/60)
      seconds = math.floor(seconds - minutes*60)
      Note("Next backup "..will_be_would_be.." in "..hours.." hours, "..minutes.." minutes, "..seconds.." seconds.")
      Note("Backup compression is currently "..(((use_compression == 1) and "enabled.") or "disabled."))
   elseif "%1" == " compressed" then
      use_compression = 1
      SetVariable("use_compression", use_compression)
      Note("Mapper backups will be compressed. This will make backups take a few seconds longer but save a bit of space.")
   elseif "%1" == " uncompressed" then
      use_compression = 0
      SetVariable("use_compression", use_compression)
      Note("Mapper backups will not be compressed. This will make backups faster but take up a bit more space.")
   else
      Note("Invalid option for mapper backups. The current automated backup setting is '"..((GetTimerInfo("backup_timer", 6) and "on") or "off").."'. Try 'mapper backups on' or 'mapper backups off' to set your desired preference.")
   end
</send>
</alias>

<alias
   match="^mapper ignore mismatch( .*)? (true|false)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
><send>
   ignore_mismatch("%1", %2)
</send></alias>

<alias
   match="^mapper noportal (.*) (true|false)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
><send>
   manual_noportal("%1", %2 and 1 or 0)
</send></alias>

<alias
   match="^mapper norecall (.*) (true|false)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
><send>
   manual_norecall("%1", %2 and 1 or 0)
</send></alias>

<alias
   match="resetaard"
   enabled="y"
   sequence="100"
   ignore_case="y"
   script="reset_aard"
></alias>

<alias
   match="^mapper quicklist( (on|off))?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="quick_mode_toggle"
></alias>

<alias
   match="^mapper shownotes( (on|off))?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="shownote_toggle"
></alias>

<alias
   match="^mapper compact( (on|off))?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="compact_mode_toggle"
></alias>

<alias
   match="mapper denser"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.denser"
></alias>
  
<alias
   match="mapper sparser"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.sparser"
></alias>  
  
<alias
   match="mapper smaller"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.smaller_rooms"
></alias>
  
<alias
   match="mapper bigger"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.bigger_rooms"
></alias>  

<alias
   match="mapper lockexit"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   send_to="12"
><send>
   room_lock_exit()
</send>
</alias>

<alias
   match="mapper findpath * *"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="map_where"
></alias>

<alias
   match="mapper find *"
   enabled="y"
   sequence="100"
   script="map_find"
   regexp="n"
></alias>
    
<alias
   match="^mapper shops?( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_shops"
></alias>  

<alias
   match="^mapper debug memorydb$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="12"
>
<send>
   if DBisOpen() then
      db:close()
   end
   db = sqlite3.open_memory()

   dbCheckExecute("ATTACH DATABASE '"..GetInfo (66) .. sanitize_filename(WorldName()) .. ".db".."' AS file_db;")

   dbCheckExecute("CREATE TABLE rooms AS SELECT * FROM file_db.rooms;")
   dbCheckExecute("CREATE TABLE bookmarks AS SELECT * FROM file_db.bookmarks;")
   dbCheckExecute("CREATE TABLE exits AS SELECT * FROM file_db.exits;")
   
   dbCheckExecute("CREATE INDEX IF NOT EXISTS exits_touid_index ON exits (touid);")
   dbCheckExecute("CREATE INDEX IF NOT EXISTS exits_dir_index ON exits (dir);")
   dbCheckExecute("CREATE INDEX IF NOT EXISTS exits_level_index ON exits (level);")
   dbCheckExecute("CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);")
   
   dbCheckExecute("DETACH DATABASE file_db;")
   
   print("DONE")
</send>
</alias>

<alias
   match="^mapper debug filedb$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="12"
>
<send>
   if DBisOpen() then
      db:close()
   end
   db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   print("DONE")
</send>
</alias>

<alias
   match="^mapper train( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_trainers"
></alias>  

<alias
   match="^mapper quest( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_quests"
></alias>  

<alias
   match="^mapper heal( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_healers"
></alias>  
  
<alias
   match="mapper goto *"
   enabled="y"
   sequence="100"
   script="map_goto"
></alias>

<alias
   match="mapper walkto *"
   enabled="y"
   sequence="100"
   script="map_goto"
></alias>

<alias
   match="mapper where *"
   enabled="y"
   sequence="100"
   script="map_where"
></alias>
  
<alias
   match="mapper thisroom"
   enabled="y"
   sequence="100"
   script="show_this_room"
   regexp="n"
></alias>
  
<alias
   match="^mapper unmapped( .+)?$"
   enabled="y"
   sequence="100"
   script="show_known_unmapped_exits"
   regexp="y"
></alias>
 
<alias
   match="^mapper notes( (.+))?$"
   enabled="y"
   regexp="y"
   sequence="100"
   script="map_notes"
></alias>
  
<alias
   match="mapper bookmarks"
   enabled="y"
   sequence="100"
   script="map_notes"
></alias>
  
<alias
   match="mapper purgezone*"
   enabled="y"
   sequence="100"
   script="map_purgezone"
></alias>  

<alias
   match="mapper purgeroom"
   enabled="y"
   sequence="100"
   send_to="12"
><send>
   if not mapper.current_room then
      print ("PURGEROOM FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
   else
      map_purgeroom(mapper.current_room)
      mapper.draw(mapper.current_room)
   end
</send>
</alias>

<alias
   match="mapper clearcache"
   enabled="y"
   sequence="100"
   script="map_clearcache"
></alias>  

<alias
   match="mapper resume"
   enabled="y"
   sequence="100"
   script="map_resume"
></alias>  
    
<alias
   match="mapper hide"
   enabled="y"
   sequence="100"
   send_to="12"
><send>
   window_hidden = true
   mapper.hide()
</send></alias>  
  
<alias
   match="mapper show"
   enabled="y"
   sequence="100"
   send_to="12"
><send>
   window_hidden = false
   mapper.show()
</send></alias>  

<alias
   match="mapper area *"
   enabled="y"
   sequence="100"
   script="map_area"
   regexp="n"
></alias>

<alias
   match="mapper list *"
   enabled="y"
   sequence="100"
   script="map_list"
   regexp="n"
></alias>

<alias
   match="^mapper next( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
>
<send>
mapper.gotoNextResult(Trim("%1"))
</send>
</alias>

<alias
   match="^mapper portals$"
   enabled="y"
   sequence="100"
   script="map_portal_list"
   regexp="y"
></alias>
 
<alias
   match="^mapper portal (.+)$"
   enabled="y"
   sequence="100"
   script="map_portal"
   regexp="y"
></alias>

<alias
   match="^mapper fullportal {(.+)} {(.+)} (\d+)$"
   enabled="y"
   sequence="100"
   script="map_portal"
   regexp="y"
></alias>


<alias
   match="^mapper delete portal (.+)$"
   enabled="y"
   sequence="100"
   script="map_portal_delete"
   regexp="y"
></alias>
  
<alias
   match="mapper portalrecall *"
   enabled="y"
   sequence="100"
   script="map_portal_recall"
   regexp="n"
></alias>

<alias
   match="mapper portallevel *"
   enabled="y"
   sequence="100"
   script="map_portal_level"
   regexp="n"
></alias>
  
<alias
   match="^mapper delete cexits$"
   enabled="y"
   sequence="100"
   script="map_cexits_delete"
   regexp="y"
></alias>  
  
<alias
   match="^mapper purge portals$"
   enabled="y"
   sequence="100"
   regexp="y"
   send_to="12"
>  
<send>
   Note("Are you sure you want to purge all portal exits? To confirm type 'mapper purge portals confirm'.")
   toConfirm = "purge portals"
   EnableAlias("confirm_catch", true)
</send>
</alias>  
  
<alias
   match="^mapper purge cexits$"
   enabled="y"
   sequence="100"
   regexp="y"
   send_to="12"
>  
<send>
   Note("Are you sure you want to purge all custom mapper exits? To confirm type 'mapper purge cexits confirm'.")
   toConfirm = "purge cexits"
   EnableAlias("confirm_catch", true)
</send>
</alias>

<alias
   match="^(.*)$"
   enabled="n"
   name="confirm_catch"
   keep_evaluating="n"
   sequence="1"
   regexp="y"
   send_to="12"
>
<send>
   if "%1" == "mapper purge cexits confirm" and toConfirm == "purge cexits" then
      map_cexits_purge()
   elseif "%1" == "mapper purge portals confirm" and toConfirm == "purge portals" then
      map_portal_purge()
   else
      Note(string.format("Failed to confirm '%s'. Aborting.", toConfirm))
   end
   toConfirm = ""
   EnableAlias("confirm_catch", false)
</send>
</alias>
  
<alias
   match="mapper cexits *"
   enabled="y"
   sequence="100"
   script="custom_exit_list"
   regexp="n"
></alias>
  
<alias
   match="mapper cexits"
   enabled="y"
   sequence="100"
   script="custom_exit_list"
   regexp="n"
></alias>

<alias
   match="^mapper cexit (.+)$"
   enabled="y"
   sequence="100"
   script="custom_exit"
   regexp="y"
></alias>

<alias
   match="^mapper cexit_wait (.+)$"
   enabled="y"
   sequence="100"
   script="change_cexit_delay"
   regexp="y"
></alias>

<alias
   match="mapper areas"
   enabled="y"
   sequence="100"
   script="map_areas"
></alias>
  
<alias
   match="mapper areas *"
   enabled="y"
   sequence="100"
   script="map_areas"
></alias>
  
<alias
   match="^mapper addnote( .*)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="12"
>
<send>
   room_edit_note(nil,nil,Trim("%1"))
</send>
</alias>

<alias
   match="^mapper bounceportal( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   script="map_bounceportal"
></alias>

<alias
   match="^mapper bouncerecall( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   script="map_bouncerecall"
></alias>

<alias
   match="^mapper help( (.*))?$"
   enabled="y"
   regexp="y"
   script="OnHelp"
></alias>

<alias
   match="^mapper updown$"
   enabled="y"
   regexp="y"
   send_to="12"
>
<send>
   mapper.show_up_down = not mapper.show_up_down
   mapper.draw(mapper.current_room)
</send>
</alias>

<alias
   match="^mapper daredevil$"
   enabled="y"
   regexp="y"
   send_to="12"
>
<send>
   mapper.daredevil_mode = not mapper.daredevil_mode
   mapper.draw(mapper.current_room)
</send>
</alias>
</aliases>

<triggers>

<trigger
   enabled="y"
   match="{begin running}"
   send_to="12"
   omit_from_output="y"
>
<send>
if not sent_busy then
   sent_busy = true
   BroadcastPlugin(999, "kinda_busy")
end
StopEvaluatingTriggers(true)
</send>
</trigger>

<trigger
   enabled="y"
   match="{end running}"
   send_to="12"
   omit_from_output="y"
>
<send>
if sent_busy then
   sent_busy = false
   BroadcastPlugin(999, "ok_you_can_go_now")
end
StopEvaluatingTriggers(true)
</send>
</trigger>
 
  <trigger
   enabled="y"
   match="^Magic walls bounce you back\.$"
   regexp="y"
   script="noportal_room"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^You cannot (recall|return home) from this room\.$"
   regexp="y"
   script="norecall_room"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="n"
   match="^Affect Flags: (.*)$"
   regexp="y"
   name="blindness_watch"
   omit_from_output="y"
   sequence="100"
   send_to="12"
  ><send>
      EnableTrigger("blindness_watch_continued", true)
      if string.find("%1","blindness") ~= nil then
         blinded = true
      end
  </send>
  </trigger>

  <trigger
   enabled="n"
   match="^(.*)$"
   regexp="y"
   name="blindness_watch_continued"
   omit_from_output="y"
   sequence="100"
   send_to="14"
  ><send>
      if "%1" == "" then
         EnableTrigger("blindness_watch", false)
         EnableTrigger("blindness_watch_continued", false)
         if not blinded then
            mark_prison_flag()
         else
            print("It looks like you are blinded.")
            print("Norecall/noportal flags will not be added until you can see again.")
         end
      elseif string.find("%1","blindness") ~= nil then
         blinded = true
      end
   </send>
  </trigger>


</triggers>

<script>
local show_timing = &show_timing;
local show_database_mods = &show_database_mods;
local show_up_down = &show_up_down;

<![CDATA[
-- ' <- fixes SublimeText Lua syntax highlighting

-- functions for handling Aardwolf color codes
dofile (GetPluginInfo (GetPluginID(), 20) .. "aardwolf_colors.lua")

require "serialize"
mapper = require "aardmapper"
require "gmcphelper"
require "tprint"
require "wait"

toConfirm = ""

-- Mapper Variables --
blinded = false
mylevel = 0
mytier = 0
window_hidden =  ((GetVariable("window_hidden") or "0") == "1") -- default false
use_compression = tonumber(GetVariable("use_compression") or 0)
quick_mode = ((GetVariable("quick_mode") or "1") == "1") -- default true
shownotes = ((GetVariable("shownotes") or "1") == "1") -- default true
compact_mode = ((GetVariable("compact_mode") or "0") == "1") -- default false
rooms = {}
environments = {}
performing_maintenance = false

room_not_in_database = {}
room_in_database = {}

bounce_recall = nil
bounce_portal = nil

function reset_aard()
   mapper.reset_pos()
   OnPluginSaveState()
   OnPluginInstall()
end

directions = {
   n=true,
   s=true,
   e=true,
   w=true,
   u=true,
   d=true
}

convert_direction = {
   north = "n",
   south = "s",
   east = "e",
   west = "w",
   up = "u",
   down = "d"
}

forced_opened = false
force_nests = 0
function forceOpenDB()
   force_nests = force_nests+1
   if not db:isopen() then
      forced_opened = true
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
end

function closeDBifForcedOpen()
   force_nests = force_nests-1
   if forced_opened and (force_nests <= 0) then
      force_nests = 0
      forced_opened = false
      db:close()
   end
end

function DBisOpen(warn)
   if db:isopen() then
      return true
   end
   if warn then
       Note("MAPPER ERROR: The map database is closed for safety when not connected to Aardwolf. If you want to change the DB, please connect to the game.")
   end
   return false
end

function dbnrowsWRAPPER(query)
   forceOpenDB()
   local nrows_elapse = utils.timer()
   iter,vm,i = db:nrows(query)
   local function itwrap(vm, i)
      retval = iter(vm, i)
      if not retval then
         closeDBifForcedOpen()
         if show_timing then
            print("dbnrowsWRAPPER elapsed ("..query:sub(1,100)..(#query > 100 and "..." or "").." ):",utils.timer()-nrows_elapse)
         end
         return nil
      end
      return retval
   end
   return itwrap,vm,i
end

function dbCheckExecute(query)
   forceOpenDB()
   local code = db:exec(query)
--~ failed attempt to make concurrent sessions viable
--~    if code == 5 or code == 6 then -- SQLITE_BUSY or SQLITE_LOCKED (oops?)
--~       wait.make (function()
--~          local code = 5
--~          local count = 0
--~          while ((code == 5 or code == 6) and count < 20) do
--~             db:exec ("ROLLBACK")
--~             wait.time(.1)
--~             code = db:exec(query)
--~             count = count + 1
--~          end
--~          dbcheck(code, query)
--~       end)
--~    else
   dbcheck(code, query)
--~    end
   closeDBifForcedOpen()
end

function dbcheck (code, query)
   if code ~= sqlite3.OK and    -- no error
      code ~= sqlite3.ROW and   -- completed OK with another row of data
      code ~= sqlite3.DONE then -- completed OK, no more rows
         local err = db:errmsg ()  -- the rollback will change the error message
         err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
         db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
         error (err, 3)            -- show error in caller's context
   end -- if
end -- dbcheck 

function fixsql (s)
   if s then
      return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
   else
      return "NULL"
   end -- if
end -- fixsql

PORTALS_QUERY = "select rooms.area,rooms.name,exits.touid,exits.fromuid,exits.dir,exits.level from exits left outer join rooms on rooms.uid=exits.touid where exits.fromuid in ('*','**') order by rooms.area,exits.touid"

function map_bounceportal (name, line, wildcards)
   wildcards[1] = Trim(wildcards[1])
   if wildcards[1]=="" then
      if bounce_portal and bounce_portal.dir then
         Note("\nBOUNCEPORTAL: Currently set to '"..bounce_portal.dir.."'")
      else
         Note("\nBOUNCEPORTAL: Not currently set.")
      end
      return
   elseif wildcards[1]=="clear" then
      bounce_portal = nil
      Note("\nBOUNCEPORTAL: cleared.")
      dbCheckExecute(string.format("DELETE from storage where name is %s;", fixsql("bounce_portal")))
      return
   end
   
   local pnum = tonumber(wildcards[1])
   
   if pnum==nil then
      Note("\nBOUNCEPORTAL FAILED: The required parameter for mapper bounceportal is <portal_index>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end
   
   local count = 1
   local found = false
   for row in dbnrowsWRAPPER(PORTALS_QUERY) do
      if count == pnum then
         if row.fromuid == "*" then
            bounce_portal = {dir=row.dir, uid=row.touid}
            Note("\nBOUNCEPORTAL: Set portal #"..count.." ("..row.dir..") as the bounce portal for portal-friendly norecall rooms.")
            dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_portal"), fixsql(serialize.save("bounce_portal"))))
         else
            Note("\nBOUNCEPORTAL FAILED: Portal #"..pnum.." is a recall portal. You must choose a mapper portal that does not use either the recall or home commands for the bounce portal.")
         end
         found = true
      end
      count = count + 1
   end
   if found == false then
      Note(string.format("\nBOUNCEPORTAL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end

function map_bouncerecall (name, line, wildcards)
   wildcards[1] = Trim(wildcards[1])
   if wildcards[1]=="" then
      if bounce_recall and bounce_recall.dir then
         Note("\nBOUNCERECALL: Currently set to '"..bounce_recall.dir.."'")
      else
         Note("\nBOUNCERECALL: Not currently set.")
      end
      return
   elseif wildcards[1]=="clear" then
      bounce_recall = nil
      Note("\nBOUNCERECALL: cleared.")
      dbCheckExecute(string.format("DELETE from storage where name is %s;", fixsql("bounce_recall")))
      return
   end

   
   local pnum = tonumber(wildcards[1])
   
   if pnum==nil then
      Note("\nBOUNCERECALL FAILED: The required input for mapper bouncerecall is <portal_index>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end
   
   local count = 1
   local found = false
   for row in dbnrowsWRAPPER(PORTALS_QUERY) do
      if count == pnum then
         if row.fromuid == "**" then
            bounce_recall = {dir=row.dir, uid=row.touid}
            Note("\nBOUNCERECALL: Set recall portal #"..pnum.." ("..row.dir..") as the bounce recall for recall-friendly noportal rooms.")
            dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_recall"), fixsql(serialize.save("bounce_recall"))))
         else
            Note("\nBOUNCERECALL FAILED: Portal #"..pnum.." is not a recall portal. You must choose a mapper portal that uses either the recall or home commands for the bounce recall.")
         end
         found = true
      end
      count = count + 1
   end
   if found == false then
      world.Note(string.format("\nBOUNCERECALL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end

function map_areas (name, line, wildcards)
   local line = ""
   local query = ""
   local area = wildcards[1] or ""
   local count = 0
    
   local hr = "| keyword    | Area Name                               | Explored |"
   local hl = "+------------+-----------------------------------------+----------+"
   local fmt = "| %10.10s | %-39.39s | %8.8s |"
   if area == "" then
      query = "SELECT uid, name FROM areas WHERE uid in (SELECT DISTINCT area FROM rooms) ORDER BY name;"
      intro = "The following areas have been mapped:"
   else
      query = string.format("SELECT uid, name FROM areas WHERE name LIKE %s AND uid in (SELECT DISTINCT area FROM rooms) ORDER BY name;", fixsql("%"..area.."%"))
      intro = string.format("The following areas matching '%s' have been mapped:",area)
   end -- if area
  
   Note ("\n"..intro)
   Note (hl)
   Note (hr)
   Note (hl)
   local total_explored = 0
   for row in dbnrowsWRAPPER(query) do
      query2 = string.format("SELECT count(uid) as count FROM rooms WHERE area=%s;",fixsql(row.uid))
      for row2 in dbnrowsWRAPPER(query2) do
         line = string.format(fmt,row.uid, row.name, row2.count)
         total_explored = total_explored + row2.count
      end
      Note (line)
      count = count + 1
      BroadcastPlugin(999, "repaint")
   end
  
   Note (hl)
   line = string.format ("Found %s areas containing %s rooms mapped.\n", count, total_explored)
   Note (line)
end

function map_list (name, line, wildcards)
   map_find(name, line, wildcards, true)
end -- map_list

function map_cexits_delete (name, line, wildcards)
   local query = string.format("delete from exits where fromuid=%s and dir not in ('n','s','e','w','d','u');", fixsql(mapper.current_room))
   dbCheckExecute(query)
   for k,v in pairs(rooms[mapper.current_room].exits) do
      if not directions[k] then
         print("Found custom exit \""..k.."\" to room "..rooms[mapper.current_room].exits[k].." \""..rooms[rooms[mapper.current_room].exits[k]].name.."\"")
         rooms[mapper.current_room].exits[k] = nil
         rooms[mapper.current_room].exit_locks[k] = nil
      end
   end
   mapper.draw (mapper.current_room)
   print("Removed custom exits from the current room.")
end

function map_cexits_purge (name, line, wildcards)
   local query = "delete from exits where dir not in ('n','s','e','w','d','u');"
   dbCheckExecute(query)
   for k,v in pairs(rooms) do
      for l,w in pairs(v.exits) do
         if not directions[l] then
            rooms[k].exits[l] = nil
            rooms[k].exit_locks[l] = nil
         end
      end
   end
   mapper.draw (mapper.current_room)
   print("Purged all custom exits.")
end

function custom_exit_list (name, line, wildcards)
   local line = ""
   local count = 0
   local query
   local display_limit = 30

   area = Trim(wildcards [1] or "")
   query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) like %s and dir not in ('n','s','e','w','d','u') and fromuid not in ('*','**') order by area, uid", fixsql("%" .. area .. "%"))

   if area == "" then
      intro = "The following rooms have custom exits:"
   else
      if area == "here" then
         
         if mapper.current_room and gmcproom.area then
            area = gmcproom.area
         else
            Note("CEXITS HERE ERROR: The mapper doesn't know where you are. Type 'LOOK' and try again.")
            return
         end
 
         query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) is %s and dir not in ('n','s','e','w','d','u') and fromuid not in ('*','**') order by uid", fixsql(area))
         intro = "The following rooms in the current area have custom exits:"
      elseif area == "thisroom" then
         if not mapper.current_room then
            Note("CEXITS THISROOM ERROR: The mapper doesn't know where you are. Type 'LOOK' and try again.")
            return
         end
         query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where fromuid=%s and dir not in ('n','s','e','w','d','u')", fixsql(mapper.current_room))
         intro = "The following custom exits are in this room:"
      else
         intro = string.format("The following rooms in areas partially matching '%s' have custom exits:",area)
      end
   end

   hr = "| area       | room name            | rm uid  | dir            | to uid  |"
   hl = "+------------+----------------------+---------+----------------+---------+"

   -- area - room name - room uid - direction - destination uid
   fmt = "| %10.10s | %-20.20s | %7.7s | %-14.14s | %7.7s |"
   -- print ("Query: " .. query)
   world.Note ("\n"..intro)
   world.Note (hl)
   world.Note (hr)
   world.Note (hl)
   
   last_result_list = {}
   next_result_index = 0
      
   for row in dbnrowsWRAPPER(query) do
      line = string.format(fmt,row.area, row.name, row.uid, row.dir, row.touid)
      mapper.addRunHyperlink(row.uid, line)
      print("")
      count = count + 1
      BroadcastPlugin(999, "repaint")
   end -- custom exits query
   world.Note (hl)
   line = string.format ("Found %s custom exits.", count)
   print (line.."\n")
end -- custom_exits_list


function show_this_room (name, line, wildcards)
   local room = rooms[mapper.current_room]
   if room ~= nil then
      Note("Details about this room:")
      Note("+---------------------------+")
      Note("Name: "..(room.name or ""))
      Note("ID: "..(mapper.current_room or ""))
      Note("Area: "..(room.area or ""))
      Note("Terrain: "..(room.terrain or ""))
      Note("Info: "..(room.info or ""))
      Note("Notes: "..(room.notes or ""))
      local flags = ''
      if room.noportal == 1 then 
         flags = flags .. ' noportal' 
      end
      if room.norecall == 1 then 
         flags = flags .. ' norecall' 
      end
      Note("Flags:", flags)
      Note("Exits: ")
      tprint(room.exits)
      Tell("Exit locks: ")
      if room.exit_locks then
         Note("")
         tprint(room.exit_locks)
      else
         Note("none")
      end
      Note("Ignore exits mismatch: ", room.ignore_exits_mismatch)
      Note("+---------------------------+\n")
   else
      Note("THISROOM ERROR: You need to type 'LOOK' first to initialize the mapper before trying to get room information.")
   end
end -- show_this_room


-- show_known_unmapped_exits function contributed by Spartacus
function show_known_unmapped_exits (name, line, wildcards)
   -- I want to get a list of exits whose destinations are not yet in the rooms table (i.e. I have not gone through the exit?)
   -- select uid, name, area from rooms inner join exits on rooms.uid = fromuid where area = area and touid not in (select uid from rooms)
   local line = ""
   local count = 0
   local query
   local display_limit = 30

   area = Trim(wildcards [1] or "")
   
   if area == "" then
      query = "select area, count(dir) as cnt from rooms inner join exits on rooms.uid = fromuid where touid not in (select uid from rooms) and touid != -1 group by area"
      hr = "| area       | count |"
      hl = "+------------+-------+"
      intro = "The following areas have unmapped exits:"
      fmt = "| %10.10s | %5d |"
   else
      if area == "here" then

         if gmcproom and gmcproom.area then
            area = gmcproom.area
         else
            Note("UNMAPPED HERE ERROR: The mapper doesn't know where you are. Type 'LOOK' and try again.")
            return
         end

         intro = "The following rooms in the current area have unmapped exits:"
      else
         intro = string.format("The following rooms in areas matching '%s' have unmapped exits:",area)
         area = "%"..area.."%"
      end
      query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) like %s and touid not in (select uid from rooms) and touid != -1 order by area, uid", fixsql(area))
      hr = "| area       | room name            | rm uid  | dir | to uid  |"
      hl = "+------------+----------------------+---------+-----+---------+"
      -- area - room name - room uid - direction - destination uid
      fmt = "| %10.10s | %-20.20s | %7.7s | %-3.3s | %7.7s |"
   end -- if area

   -- print ("Query: " .. query)
   world.Note ("\n"..intro)
   world.Note (hl)
   world.Note (hr)
   world.Note (hl)
   
   last_result_list = {}
   next_result_index = 0
  
   for row in dbnrowsWRAPPER(query) do
      if area == "" then
         line = string.format(fmt,row.area, row.cnt)
         world.Note (line)
         count = count + row.cnt
      else
         line = string.format(fmt,row.area, row.name, row.uid, row.dir, row.touid)
         mapper.addRunHyperlink(row.uid, line)
         print("")
         count = count + 1
      end -- if count
   end -- unmapped rooms query
   
   world.Note (hl)
   line = string.format ("Found %s unmapped exits.", count)
   print (line.."\n")
end -- show_known_unmapped_exits

function map_portal_delete (name, line, wildcards)
   local keywords = wildcards[1]
   local target_index = nil
   if string.sub(keywords,1,1) == "#" and type(tonumber(string.sub(keywords,2)))=="number" then
      target_index = tonumber(string.sub(keywords,2))
      local count = 0
      local found = false
      for row in dbnrowsWRAPPER(PORTALS_QUERY) do
         count = count + 1
         if count == target_index then
            keywords = row.dir
            found = true
         end
      end
      if found == false then
         world.Note(string.format("\nDELETE FAILED: Did not find portal #%s in the list of portals. Try 'mapper portals' to see the list.\n", target_index))
         return
      end
   end

   local portal_exists = false
   for n in dbnrowsWRAPPER (string.format ("SELECT * FROM exits WHERE fromuid in ('*','**') AND dir = %s", fixsql(keywords))) do
      portal_exists = true
   end
   
   if portal_exists then
      print (string.format("Deleted mapper portal"..(((target_index ~= nil) and " index #"..target_index) or "").." with keywords '%s'.", keywords))
   else
      print (string.format("DELETE FAILED: Did not find a mapper portal with keywords '%s'.", keywords))
   end
   
   query = string.format("DELETE FROM exits WHERE fromuid in ('*','**') AND dir = %s;", fixsql(keywords))
   dbCheckExecute(query)
   if bounce_recall and (bounce_recall.dir == keywords) then
      Note("Detected matching bounce recall.")
      map_bouncerecall(nil, nil, {"clear"})
   end
   if bounce_portal and (bounce_portal.dir == keywords) then
      Note("Detected matching bounce portal.")
      map_bounceportal(nil, nil, {"clear"})
   end
end -- map_portal_delete

function map_portal_purge(name, line, wildcards)
   query = "DELETE FROM exits WHERE fromuid in ('*','**');"
   dbCheckExecute(query)
   print ("Purged all mapper portals.")
   map_bouncerecall(nil, nil, {"clear"})
   map_bounceportal(nil, nil, {"clear"})
end

function positive_integer_check(input)
   input = tonumber(input)
   if input == nil or input < 0 or input % 1 ~= 0 then
      return false
   else
      return true
   end
end

function level_check(input)
   input = tonumber(input)
   if positive_integer_check(input) == false then
      return false
   else
      return true
   end
end

function map_portal_recall (name, line, wildcards)
   -- flag a portal as using "recall"   
   local query = "INSERT OR REPLACE INTO rooms (uid, name, area) VALUES ('**', '___HERE___', '___EVERYWHERE___')"
   dbCheckExecute(query)
   
   local pnum = tonumber(wildcards[1])
   
   if pnum==nil then
      world.Note("\nPORTALRECALL FAILED: The required parameter for mapper portalrecall is <portal_index>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end
   
   local count = 1
   local found = false
   for row in dbnrowsWRAPPER(PORTALS_QUERY) do
      if count == pnum then
         query = string.format ([[
            INSERT OR REPLACE INTO exits (dir, fromuid, touid, level) 
            VALUES (%s, %s, %s, %s);
            ]], 
            fixsql(row.dir),  -- direction (eg. "n")
            fixsql(((row.fromuid == "*") and "**") or "*"),  -- toggle between '*' and '**'
            fixsql(row.touid),    -- destination room
            fixsql(row.level)
         )
         dbCheckExecute(query)
         query = string.format ([[
            DELETE FROM exits WHERE dir=%s AND fromuid=%s AND touid=%s AND level=%s;
            ]], 
            fixsql(row.dir),  -- direction (eg. "n")
            fixsql(row.fromuid),  -- remove the old pre-toggle entry
            fixsql(row.touid),    -- destination room
            fixsql(row.level)
         )
         dbCheckExecute(query)
         
         world.Note(string.format("\nPORTALRECALL: Recall flag %s portal '%s' to '%s'.\n",((row.fromuid == "*") and "added to") or "removed from",row.dir,(row.name or "N/A")))
         found = true
      end
      count = count + 1
   end
   if found == false then
      world.Note(string.format("\nPORTALRECALL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end -- map_recall

-- first map_portal function was contributed by Spartacus.
function map_portal (name, line, wildcards)
   -- store portal as an exit from anywhere to the current or given room
   local destination = wildcards[2] or mapper.current_room  
   
   if not destination then
      print ("PORTAL FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end
   
   if not get_room(destination) then 
      print("PORTAL ["..wildcards[1].."] FAILED: Room "..destination.." is unknown.")
      return
   end
   
   local level = (level_check(wildcards[3]) and wildcards[3]) or tonumber(utils.inputbox (string.format("Please enter the level of your portal to %s, or leave at 0 for the default",destination), "Portal Level", "0", "Courier", 9, {validate=level_check}))
   
   if not level then
      Note("Portal creation cancelled.")
      return
   end
     
   create_portal(wildcards[1], destination, level)

end -- map_portal

function create_portal(keyword, destination, level)
   local hhp_room_exists = 0
   local query = ""
   keyword = Trim(keyword)
   -- first check to see if our special 'from anywhere' room exists...
   for row in dbnrowsWRAPPER("select * from rooms where uid='*'") do
      hhp_room_exists = hhp_room_exists + 1
   end
   if hhp_room_exists == 0 then
      query = "INSERT OR REPLACE INTO rooms (uid, name, area) VALUES ('*', '___HERE___', '___EVERYWHERE___')"
      dbCheckExecute(query)
   end
   print (string.format("Storing '%s' as a portal to %s.", keyword, destination))
   print (string.format("\nPortal given minimum level lock of %s.\n", level))
   query = string.format ("INSERT OR REPLACE INTO exits (dir, fromuid, touid, level) VALUES (%s, %s, %s, %s);", 
      fixsql  (keyword),
      fixsql  ("*"),           -- from anywhere
      fixsql  (destination),
      fixsql(level) -- minimum level of the portal
   )
   dbCheckExecute(query)
end

function string:split(pat)
   local fields = {}
   local start = 1
   self:gsub("()("..pat..")", 
      function(c,d)
         table.insert(fields,self:sub(start,c-1))
         start = c + #d
      end
   )
   table.insert(fields, self:sub(start))
   return fields
end

function map_portal_level (name, line, wildcards)
  
   local keys = Trim(wildcards[1]):split("[%s]+")
   local pnum = tonumber(keys[1])
   local level = tonumber(keys[2])

   if pnum==nil or level==nil then
      world.Note("\nPORTALLEVEL FAILED: The parameters for mapper portal level are <portal_index> <min_level>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end
  
   if level < 0 then
      level = 0
   end
 
   local count = 1
   local found = false
   for row in dbnrowsWRAPPER(PORTALS_QUERY) do
      if count == pnum then
         query = string.format ([[
            INSERT OR REPLACE INTO exits (dir, fromuid, touid, level) 
            VALUES (%s, %s, %s, %s);
            ]], 
            fixsql(row.dir),  -- direction (eg. "n")
            fixsql(row.fromuid),  -- from '*' or '**'
            fixsql(row.touid),    -- destination room
            fixsql(level)
         )
         dbCheckExecute(query)
         world.Note(string.format("\nPortal '%s' to '%s' given minimum level lock of %s.\n",row.dir,row.name,level))
         found = true
      end
      count = count + 1
   end
   if found == false then
      world.Note(string.format("\nPORTALLEVEL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end -- map_portal_level

-- map_portal_list function contributed by Spartacus
function map_portal_list ()
   local line
   local cmd
   local txt
   -- show portals stored in the exits table
   local hl = "+-----+------------+----------------------+-------+----------------------+-----+"
   local hr = "|   # | area       | room name            |  vnum | portal commands      | lvl |"

   Note ("\n"..hl)
   Note (hr)
   Note (hl)
   
   last_result_list = {}
   next_result_index = 0
   
   local count = 0
   for row in dbnrowsWRAPPER(PORTALS_QUERY) do
      count = count + 1
      line = string.format("|"..((((bounce_portal and (row.dir==bounce_portal.dir)) or (bounce_recall and (row.dir==bounce_recall.dir))) and "*") or " ").."%+3.3s | %-10.10s | %-20.20s | %+5.5s | %-20.20s | %+3.3s |", count, row.area or "N/A", row.name or "N/A", row.touid, row.dir, row.level)
      if row.level <= mylevel+(mytier*10) then
         mapper.addRunHyperlink(row.touid, line, "\nPortal Action: "..row.dir, true, ((row.fromuid=="*") and "") or "red")         
         Note()
      else
         Note(line)
      end -- if row.level
   end -- for row (portals query)
   
   Note (hl)
   Note ("|* Indicates designated bouncerecall/bounceportal |")
   Note ("+-------------------------------------------------+\n")
   
end -- map_portal_list

BASE_CEXIT_DELAY = 2

function change_cexit_delay(name, line, wildcards)
   temp_cexit_delay = tonumber(wildcards[1])
   if not compact_mode then Note("") end
   if temp_cexit_delay == nil or temp_cexit_delay < BASE_CEXIT_DELAY or temp_cexit_delay > 40 then
      Note("CEXIT_DELAY FAILED: Invalid delay given ("..wildcards[1].."). Must be a number from 2 to 40.")
      temp_cexit_delay = nil
   end
   Note("CEXIT_DELAY: The next mapper custom exit will have ".. (temp_cexit_delay or BASE_CEXIT_DELAY) .." seconds to complete.\n")
end

function ExecuteWithWaits(cexit_command)
   wait.make (function()
      SendNoEcho("echo {begin running}")
      local partial_cexit_command = cexit_command
      local strbegin,strend = string.find(partial_cexit_command,"wait%(%d*.?%d+%)")
      while strbegin do
         strbegin,strend = string.find(partial_cexit_command,"wait%(%d*.?%d+%)")
         if strbegin ~= nil and strbegin ~= 1 then
            Execute(string.sub(partial_cexit_command,1,strbegin-1))
         end
         if strend then
            local wait_time = tonumber(string.match(string.sub(partial_cexit_command,strbegin,strend),"wait%((%d*.?%d+)%)"))
            SendNoEcho("echo {mapper_wait}wait("..wait_time..")")
            line, wildcards = wait.regexp("^\\{mapper_wait\\}wait\\(([0-9]*\\.?[0-9]+)\\)",nil,trigger_flag.OmitFromOutput)
            Note("CEXIT WAIT: waiting for "..wait_time.." seconds before continuing.")
            BroadcastPlugin(999, "repaint")
            wait.time(wait_time)
            partial_cexit_command = string.sub(partial_cexit_command, strend+1)
         end
      end
      Execute(partial_cexit_command)
      SendNoEcho("echo {end running}")
   end)
end

-- custom_exit function contributed by Spartacus
function custom_exit (name, line, wildcards)

   local cexit_command = wildcards [1] or ""
   local cexit_start
  
   if cexit_command == "" then
      world.Note("Nothing to do!")
      return
   end -- if cexit_command
   
   -- Note: Since the addition of the ignore_exits_mismatch room flag, I think this is no longer true.
   --       Getting rid of the remap allows one to draw custom exit linkages between nomap rooms.
   ------------------------------------
   -- the current system makes standard letter exit (n,e,s,w,d,u) cexits not usable, so remap them
   -- to their long word forms
   --local remap = {
   --   n = "north",
   --   w = "west",
   --   s = "south",
   --   e = "east",
   --   u = "up",
   --   d = "down"
   --}
   --if remap[cexit_command] then
   --   cexit_command = remap[cexit_command]
   --end
   if mapper.current_room then
      cexit_start = mapper.current_room
   else
      world.Note("CEXIT FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end -- if mapper.current_room

   if cexit_start == "-1" then
      world.Note ("CEXIT FAILED: You cannot link custom exits from unmappable rooms.")
      return
   end
  
   wait.make (function()
      local cexit_delay = temp_cexit_delay or BASE_CEXIT_DELAY
      local added_waits = 0
      for wait_secs in string.gmatch(cexit_command, "wait%((%d*.?%d+)%)") do
         added_waits = added_waits + tonumber(wait_secs)
      end
      world.Note("CEXIT: WAIT FOR CONFIRMATION BEFORE MOVING.\nThis should take about "..cexit_delay+added_waits.." seconds"..(((added_waits ~= 0) and " (includes "..added_waits.." seconds in added waits)") or "")..".")
      BroadcastPlugin(999, "repaint")
      ExecuteWithWaits(cexit_command)

      wait.time(cexit_delay+added_waits)
      temp_cexit_delay = nil
      cexit_dest = mapper.current_room
      if cexit_dest then
         if cexit_dest == "-1" then
            world.Note ("CEXIT FAILED: You cannot link custom exits to unmappable rooms.")
         elseif cexit_dest ~= cexit_start then
            world.Note (string.format("Custom Exit CONFIRMED: %s (%s) -> %s", cexit_start, cexit_command, cexit_dest))
            dbCheckExecute(string.format ("INSERT OR REPLACE INTO exits (dir, fromuid, touid) VALUES (%s, %s, %s);",
               fixsql  (cexit_command),  -- direction (eg. "n")
               fixsql  (cexit_start),  -- from current room
               fixsql  (cexit_dest) -- destination room 
            ))
            rooms[cexit_start].exits[cexit_command] = cexit_dest
            rooms[cexit_start].exit_locks[cexit_command] = "0"
            mapper.draw (mapper.current_room)
         else
            world.Note (string.format("CEXIT FAILED: Custom Exit %s leads back here!", cexit_command))
         end
      else
         world.Note ("CEXIT FAILED: Need to know where we ended up.")
      end
   end)
end -- custom_exit

function save_room_to_database (uid,room)
   assert (uid, "No UID supplied to save_room_to_database")
   
   dbCheckExecute(string.format (
         "INSERT OR REPLACE INTO rooms (uid, name, area, terrain, info, noportal, norecall, ignore_exits_mismatch) VALUES (%s, %s, %s, %s, %s, %d, %d, %d);",
            fixsql(uid),
            fixsql(room.name),
            fixsql(room.area),
            fixsql(room.terrain), 
            fixsql(room.info),
            room.noportal or 0,
            room.norecall or 0,
            room.ignore_exits_mismatch and 1 or 0
         ))

   room_not_in_database [uid] = nil
   mapper.room_display_params[uid] = nil

   if show_database_mods then
      mapper.mapprint ("Added room", uid, "to database. Name:", room.name)
   end -- if
end -- function save_room_to_database

function purgezone(zoneuid)
   local query = "BEGIN TRANSACTION;"
   query = query..string.format ("delete from exits where touid in (select uid from rooms where area = %s);",fixsql(zoneuid))
   query = query..string.format ("delete from exits where fromuid in (select uid from rooms where area = %s);",fixsql(zoneuid))
   query = query..string.format ("delete from bookmarks where uid in (select uid from rooms where area = %s);", fixsql(zoneuid))
   query = query..string.format ("delete from rooms where area = %s;", fixsql(zoneuid))
   query = query..string.format ("delete from areas where uid = %s;", fixsql(zoneuid))
   query = query.."COMMIT;"

   if show_database_mods then
      mapper.mapprint("Purging zone "..zoneuid.." with: "..query)
   end

   dbCheckExecute(query)

   for k,v in pairs(rooms) do
      for j,u in pairs(v.exits) do
         if (rooms[u] ~= nil) and (rooms[u].area == zoneuid) then
            v.exits[j] = nil
         end
      end
   end
   for k,v in pairs(rooms) do
      if v.area == zoneuid then
         rooms[k] = nil
         mapper.room_display_params[k] = nil
      end
   end
   mapper.areas[zoneuid] = nil
   lastarea = ""
   Send_GMCP_Packet("request room")
end

function map_purgezone (name, line, wildcards)
   local zoneuid = string.gsub(wildcards[1], "^%s*(.-)%s*$", "%1")
   local found = false
   local zone_name = ""
   if #(wildcards[1]) > 1 and string.sub(wildcards[1], 1, 1) == " " then
      for row in dbnrowsWRAPPER(string.format("SELECT name FROM areas WHERE uid = %s;", fixsql (zoneuid))) do
         zone_name = row.name
         found = true
      end   -- finding area uid
   end
  
   if found == false then
      mapper.mapprint("Syntax: mapper purgezone <keyword>\nTry 'mapper areas' for a list of area keywords.\n")
      return
   end

   purgezone(zoneuid)

   mapper.mapprint ("Purged " .. zone_name .. " from the mapper database.")
end

function room_purgeroom (room, uid)
   map_purgeroom(uid)
   mapper.draw(mapper.current_room)
end

function map_purgeroom (uid, new_area)
   local query = "BEGIN TRANSACTION;"
   if new_area then
      query = query..string.format ("delete from exits where touid = %s and fromuid not in (select uid from rooms where area = %s);",fixsql(uid),fixsql(new_area))
   else
      query = query..string.format ("delete from exits where touid = %s;",fixsql(uid))
   end
   query = query..string.format ("delete from exits where fromuid = %s;",fixsql(uid))
   query = query..string.format ("delete from bookmarks where uid = %s;", fixsql(uid))
   query = query..string.format ("delete from rooms where uid = %s;", fixsql(uid))
   query = query.."COMMIT;"
   dbCheckExecute(query)

   rooms[uid] = nil
   for k,v in pairs(rooms) do
      for j,u in pairs(v.exits) do
         if u == uid then
            v.exits[j] = nil
         end
      end   
   end
end

function map_clearcache() 
   rooms = {}
   mapper.mapprint ("Cleared local room cache.")
end

function load_all_rooms ()
   if not rooms then
      rooms = {}
   end

   for row in dbnrowsWRAPPER("SELECT * from rooms") do
      rooms[row.uid] = {
         name = row.name,
         area = row.area,
         terrain = row.terrain,
         info = row.info,
         noportal = row.noportal,
         norecall = row.norecall,
         ignore_exits_mismatch = (row.ignore_exits_mismatch == 1),
         exits = {},
         exit_locks = {}
      }
   end
   for row in dbnrowsWRAPPER("SELECT * from exits") do
      rooms[row.fromuid].exits[row.dir] = tostring(row.touid)
      rooms[row.fromuid].exit_locks[row.dir] = tostring(row.level)
   end   -- finding room
   for bmrow in dbnrowsWRAPPER("SELECT * FROM bookmarks") do
      rooms[bmrow.uid].notes = bmrow.notes
   end   -- finding room
   for row in dbnrowsWRAPPER("SELECT * FROM room_colors") do
      rooms[row.roomid].color = row.color
      rooms[row.roomid].color2 = row.color2
      rooms[row.roomid].fillbrush = row.fillbrush
   end
end

function get_room (uid)
   return rooms[uid]
end -- get_room


function create_tables ()
   -- create rooms table
   dbCheckExecute([[
   PRAGMA foreign_keys = ON;

   CREATE TABLE IF NOT EXISTS areas (
      areaid      INTEGER PRIMARY KEY AUTOINCREMENT,
      uid         TEXT    NOT NULL,   -- vnum or how the MUD identifies the area
      name        TEXT,               -- name of area
      date_added  DATE,               -- date added to database
      texture     TEXT,               -- background area texture
      color       TEXT,               -- ANSI colour code.
      flags       TEXT NOT NULL DEFAULT '',      -- area flags
      UNIQUE (uid)
   );
   CREATE INDEX IF NOT EXISTS areas_uid_index ON areas (uid);
   CREATE INDEX IF NOT EXISTS areas_name_index ON areas (name);

   CREATE TABLE IF NOT EXISTS environments (
      environmentid INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT    NOT NULL,   -- code for the environment
      name          TEXT,               -- name of environment
      color         INTEGER,            -- ANSI colour code
      date_added    DATE,               -- date added to database
      UNIQUE (uid)
   );
   CREATE INDEX IF NOT EXISTS name_index ON environments (name);
   
   CREATE TABLE IF NOT EXISTS rooms (
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT NOT NULL,   -- vnum or how the MUD identifies the room
      name          TEXT,            -- name of room
      area          TEXT,            -- which area
      building      TEXT,            -- which building it is in
      terrain       TEXT,            -- eg. road OR water
      info          TEXT,            -- eg. shop,healer
      notes         TEXT,            -- player notes
      x             INTEGER,
      y             INTEGER,
      z             INTEGER,
      date_added    DATE,            -- date added to database
      UNIQUE (uid),
      FOREIGN KEY(area) REFERENCES areas(uid)
   );
   CREATE INDEX IF NOT EXISTS info_index ON rooms (info);
   CREATE INDEX IF NOT EXISTS terrain_index ON rooms (terrain);
   CREATE INDEX IF NOT EXISTS area_index ON rooms (area);
   CREATE INDEX IF NOT EXISTS rname_index ON rooms (name);  

   CREATE TABLE IF NOT EXISTS exits (
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     TEXT    NOT NULL, -- exit from which room (in rooms table)
      touid       TEXT    NOT NULL, -- exit to which room (in rooms table)
      level       STRING  NOT NULL DEFAULT '0', -- minimum level to make use of this exit
      date_added  DATE,             -- date added to database
      PRIMARY KEY(fromuid, dir),
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
   );
   CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
   CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
   ]])
  
   -- Since the MUD sends terrain as a string and not as an integer,
   -- it was wrong to originally produce rooms with integer terrains.
   -- Or maybe it's wrong for the MUD to send strings. Either way, we now
   -- have databases with inconsistent data. So let's make it consistent.
   dbCheckExecute("UPDATE OR IGNORE rooms SET terrain = ifnull((SELECT name FROM environments WHERE environments.uid = rooms.terrain), rooms.terrain);")
end -- function create_tables

function check_rooms_flags()
   local flag_exists = { noportal = false,
                         norecall = false }
   for a in dbnrowsWRAPPER "PRAGMA table_info('rooms')" do
      if flag_exists[a.name] ~= nil then
         flag_exists[a.name] = true
      end
   end
   
   for k, v in pairs(flag_exists) do
      if not v then
         local sql = 'ALTER TABLE rooms ADD ' .. k .. ' INTEGER'
         dbCheckExecute(sql)
      end
   end
end -- function check_rooms_flags

function room_edit_note (room, uid, newnotes)

   if uid == nil and mapper.current_room ~= nil then 
      uid = mapper.current_room
      room = rooms[mapper.current_room]
   end
   
   if uid == nil then -- still nothing?
      print("No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end

   local notes, found
  
   for row in dbnrowsWRAPPER(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (uid))) do
      notes = row.notes
      found = true
   end   -- finding room
  
   if newnotes == nil or newnotes == "" then
      if found then  
         newnotes = utils.inputbox ("Modify room comment (clear it to delete from database)", room.name, notes)
      else
         newnotes = utils.inputbox ("Enter room comment (creates a note for this room)", room.name, notes)
      end -- if
   end
   
   if not newnotes then
      return
   end -- if cancelled 
  
   if newnotes == "" then
      if not found then
         mapper.mapprint ("No comment entered, note not saved.")
         return
      else
         dbCheckExecute(string.format (
         "DELETE FROM bookmarks WHERE uid = %s;",
         fixsql (uid)
         ))
         mapper.mapprint ("Note for room", uid, "deleted. Was previously:", notes)
         mapper.room_display_params[uid] = nil
         rooms [uid].notes = nil   
         mapper.draw (mapper.current_room)
         return
      end -- if
   end -- if
  
   if notes == newnotes then
      return -- no change made
   end -- if
  
   if found then
      dbCheckExecute(string.format (
      "UPDATE bookmarks SET notes = %s WHERE uid = %s;",
      fixsql (newnotes),
      fixsql (uid)
      ))
      mapper.mapprint ("Note for room", uid, "changed to:", newnotes)
   else
      dbCheckExecute(string.format (
      "INSERT INTO bookmarks (uid, notes) VALUES (%s, %s);",
      fixsql (uid), 
      fixsql (newnotes)
      ))
      mapper.mapprint ("Note added to room", uid, ":", newnotes)
   end -- if    
   
   rooms [uid].notes = newnotes
   mapper.room_display_params[uid] = nil
   mapper.draw (mapper.current_room)
   
end -- room_edit_note

brush_selection = {
   [miniwin.brush_solid]="Solid",
   [miniwin.brush_hatch_horizontal]="Hatch - horizontal",
   [miniwin.brush_hatch_vertical]="Hatch - vertical",
   [miniwin.brush_hatch_forwards_diagonal]="Hatch - forwards diagonal",
   [miniwin.brush_hatch_backwards_diagonal]="Hatch - backwards diagonal",
   [miniwin.brush_hatch_cross]="Hatch - cross",
   [miniwin.brush_hatch_cross_diagonal]="Hatch - diagonal cross",
   [miniwin.brush_fine_pattern]="Checkboard - fine",
   [miniwin.brush_medium_pattern]="Checkboard - medium",
   [miniwin.brush_coarse_pattern]="Checkerboard - coarse",
   [miniwin.brush_waves_horizontal]="Waves - horizontal",
   [miniwin.brush_waves_vertical]="Waves - vertical"
}

function room_remove_custom_colour(room, uid)
   local color = room.color
   local color2 = room.color2
   local fillbrush = room.fillbrush

   if color and fillbrush and (color2 or (fillbrush == miniwin.brush_solid)) then
      dbCheckExecute(string.format (
      "DELETE FROM room_colors WHERE roomid = %s;",
      fixsql(uid)
      ))
      room.color = nil
      room.color2 = nil
      room.fillbrush = nil
      mapper.mapprint("Color for room '"..uid.."' has been reset to terrain+info default. It was previously "..RGBColourToName(color)..((fillbrush ~= miniwin.brush_solid) and (" on "..RGBColourToName(color2)) or "").." using '"..brush_selection[fillbrush].."' brush.")
      mapper.room_display_params[uid] = nil
      mapper.draw(mapper.current_room)
   else
      mapper.mapprint("Room '"..uid.."' had no custom color assigned.")
   end
end

function room_edit_custom_colour(room, uid)
   local color = room.color
   local color2 = room.color2
   local fillbrush = room.fillbrush

   color = PickColour(color or 0)
   if color == -1 then
      color = nil
   end

   if color then
      fillbrush = utils.listbox ("Choose a room texture.\r\nIf you choose a texture other than solid, you will be asked for a second color.", "Texture Picker", 
         brush_selection, 
         fillbrush or miniwin.brush_fine_pattern)

      if fillbrush and fillbrush ~= miniwin.brush_solid then
         color2 = PickColour(color2 or 0)
         if color2 == -1 then
            color2 = nil
         end
      end
   end

   if color and fillbrush and (color2 or (fillbrush == miniwin.brush_solid)) then
      dbCheckExecute(string.format (
         "INSERT OR REPLACE INTO room_colors (roomid, color, fillbrush, color2) VALUES (%s, %d, %d, %d);",
         fixsql(uid),
         color,
         fillbrush,
         color2 or 0
         ))
      room.color = color
      room.color2 = color2
      room.fillbrush = fillbrush
      mapper.mapprint("Color for room '"..uid.."' is now "..RGBColourToName(color)..((fillbrush ~= miniwin.brush_solid) and (" on "..RGBColourToName(color2)) or "").." using '"..brush_selection[fillbrush].."' brush.")
      mapper.room_display_params[uid] = nil
      mapper.draw(mapper.current_room)
   else
      mapper.mapprint("Custom room color selection cancelled.")
   end
end

function room_edit_terrain_colour (room, uid)
   if not room.terrain then
      utils.msgbox("This room does not have a terrain type", "Unknown terrain!", "ok", "!", 1)
      return
   end -- not known
   
   local environmentname = room.terrain  
   local color = mapper.user_terrain_colour[environmentname].color
   local color2 = mapper.user_terrain_colour[environmentname].color2
   local fillbrush = mapper.user_terrain_colour[environmentname].fillbrush

   color = PickColour(color or 0)
   if color == -1 then
      color = nil
   end

   if color then
      fillbrush = utils.listbox ("Choose a terrain texture.\r\nIf you choose a texture other than solid, you will be asked for a second color.", "Texture Picker", 
         brush_selection, 
         fillbrush or miniwin.brush_fine_pattern)

      if fillbrush and fillbrush ~= miniwin.brush_solid then
         color2 = PickColour(color2 or 0)
         if color2 == -1 then
            color2 = nil
         end
      end
   end

   if color and fillbrush and (color2 or (fillbrush == miniwin.brush_solid)) then
      dbCheckExecute(string.format (
         "INSERT OR REPLACE INTO terrain (name, color, fillbrush, color2) VALUES (%s, %d, %d, %d);",
         fixsql(environmentname), 
         color,
         fillbrush,
         color2 or 0
         ))
      mapper.mapprint("Color for terrain '"..environmentname.."' is now "..RGBColourToName(color)..((fillbrush ~= miniwin.brush_solid) and (" on "..RGBColourToName(color2)) or "").." using '"..brush_selection[fillbrush].."' brush.")
      mapper.user_terrain_colour[environmentname] = {color = color, color2 = color2, fillbrush = fillbrush}
      mapper.room_display_params = {}
      mapper.draw(mapper.current_room)
   else
      mapper.mapprint("Custom terrain color selection cancelled.")
   end

end -- room_edit_terrain_colour


function room_delete_exit (room, uid, exit)
   local chosen_exit = exit

   if chosen_exit == nil then
      local available =  {}  -- end of available

      -- construct available exits list for display
      for k,v in pairs (room.exits) do
         available [k] = k .. " --> " .. room.exits [k] 
      end -- for
      
      if next (available) == nil then
         utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
         return
      end -- not known
     
      local chosen_exit = utils.listbox ("Choose exit to delete", "Exits ...", available )
      if not chosen_exit then
         return
      end
   end

   dbCheckExecute(string.format ([[
      DELETE FROM exits WHERE dir = %s AND fromuid = %s;
      ]], 
      fixsql (chosen_exit),  -- direction (eg. "n")
      fixsql (uid)  -- from current room
   ))
   mapper.mapprint ("Deleted exit '"..chosen_exit.."' from room "..uid.." from database.")

   -- update in-memory table
   rooms[uid] = nil
   get_room(uid)
  
   mapper.draw (mapper.current_room)
   
end -- room_delete_exit


function room_change_exit (room, uid, exit)
   local chosen_exit = exit

   if chosen_exit == nil then
      local available =  {}  -- end of available

      -- construct available exits list for display
      for k,v in pairs (room.exits) do
         available [k] = k .. " --> " .. room.exits [k] 
      end -- for
     
      if next (available) == nil then
         utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
         return
      end -- not known
     
      local chosen_exit = utils.listbox ("Choose exit to change destination of:", "Exits ...", available )
      if not chosen_exit then
         return
      end
   end

   exit_destination = utils.inputbox ("Enter destination room identifier (number) for " .. chosen_exit, room.name, room.exits[chosen_exit])

   if not exit_destination then
      return
   end -- cancelled
  
   -- look it up
   local dest_room = get_room(exit_destination)
  
   if not dest_room then
      utils.msgbox ("Room " .. exit_destination .. " does not exist.", "Room does not exist!", "ok", "!", 1)
      return
   end -- if still not there
   
   if exit_destination ~= room.exits[chosen_exit] then
      dbCheckExecute(string.format ([[
         UPDATE exits SET touid = %s WHERE dir = %s AND fromuid = %s;
         ]], 
         fixsql (exit_destination),
         fixsql (chosen_exit),  -- direction (eg. "n")
         fixsql (uid)  -- from current room
      ))
         
      mapper.mapprint ("Modified exit", chosen_exit, "from room", uid, "to be to room", exit_destination, "in database.")
     
      -- update in-memory table
      rooms[uid].exits[chosen_exit] = exit_destination
      mapper.draw(mapper.current_room)
   else
      mapper.mapprint ("Destination unchanged for exit '"..chosen_exit.."'.")
   end
      
end -- room_change_exit

function room_lock_exit (room, uid, exit)
   if uid == nil and mapper.current_room ~= nil then
      uid = mapper.current_room
      room = rooms[uid]
   end
   
   if uid == nil then -- still nothing? abort!
      print("No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end
   
   -- construct available exits list for display
   local available = {}
   for k,v in pairs (room.exits) do
      available [k] = k .. " --> " .. room.exits [k] 
   end -- for

   local chosen_exit = exit
   if chosen_exit == nil then
      if next (available) == nil then
         utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
         return
      end -- not known
     
      chosen_exit = utils.listbox ("Choose exit to lock:", "Exits ...", available )
      if not chosen_exit then
         return
      end -- cancelled
   end
   
   exit_level = tostring(tonumber(utils.inputbox ("Enter level lock for " .. chosen_exit, room.name, room.exit_locks[chosen_exit],nil,nil,{validate=positive_integer_check}))) -- use tonumber to strip off any ".0"

   if exit_level == "nil" then
      return
   end -- cancelled
   
   if not rooms [uid].exit_locks then
      rooms [uid].exit_locks = {}
   end

   if exit_level ~= rooms[uid].exit_locks[chosen_exit] then
      dbCheckExecute(string.format ([[
         UPDATE exits SET level = %s WHERE dir = %s AND fromuid = %s;
         ]], 
         fixsql (exit_level),
         fixsql (chosen_exit), -- direction (eg. "n")
         fixsql (uid) -- from current room
      ))
         
      mapper.mapprint ("Set level lock on exit", available [chosen_exit], "from room", uid, "to be", exit_level, "in database.")
   else
      mapper.mapprint ("Level lock unchanged for exit '"..chosen_exit.."'.")
   end

   -- update in-memory table
   rooms[uid].exit_locks[chosen_exit] = exit_level
   mapper.draw(mapper.current_room)
   
end -- room_lock_exit

function room_click (uid, flags)

   -- check we got room at all
   if not uid then
      return nil
   end -- if
  
   -- look it up
   local room = get_room(uid)
  
   if not room then
      return
   end -- if still not there
   
   local handlers = {}
   table.insert(handlers, { name = "Edit Note", func = room_edit_note})
   table.insert(handlers, { name = "Edit ["..room.terrain.."] Terrain Color", func = room_edit_terrain_colour})

   table.insert(handlers, { name = ">Edit Room-specific Color", })
   if room.color then
      table.insert(handlers, { name = RGBColourToName(room.color)..((room.fillbrush ~= miniwin.brush_solid) and 
         (" on "..RGBColourToName(room.color2)) or "")..
      " using '"..brush_selection[room.fillbrush].."' brush", func = function() end})
   else
      table.insert(handlers, { name = "^Not Set", })
   end
   table.insert(handlers, { name = "-", })
   if room.color then
      table.insert(handlers, { name = "Remove", func = room_remove_custom_colour})
   else
      table.insert(handlers, { name = "^Remove", })
   end
   table.insert(handlers, { name = "Change", func = room_edit_custom_colour})
   table.insert(handlers, { name = "<", })

   table.insert(handlers, { name = "-", })
   
   table.insert(handlers, { name = ">Change Exit", })
   for ex, to in pairs(room.exits) do
      table.insert(handlers, { name = ex.." -> "..to, func = room_change_exit, param = ex})
   end
   table.insert(handlers, { name = "<", })

   table.insert(handlers, {name = ">Change Exit Level Lock", })
   for ex, lock in pairs(room.exit_locks) do
      table.insert(handlers, { name = ex.."  [ "..lock.." ]", func = room_lock_exit, param = ex})
   end
   table.insert(handlers, { name = "<", })

   table.insert(handlers, { name = "-", })
   table.insert(handlers, { name = (room.ignore_exits_mismatch and "+" or "").."Ignore Exits Mismatch Here", func = ignore_mismatch_toggle, param = room.ignore_exits_mismatch})
   table.insert(handlers, { name = ">Delete Exit", })
   for ex, to in pairs(room.exits) do
      table.insert(handlers, { name = ex.." -> "..to, func = room_delete_exit, param = ex})
   end
   table.insert(handlers, { name = "<", })
   
   table.insert(handlers, { name = "Delete Room", func = room_purgeroom})
      
   rc, a, b, c = CallPlugin("60840c9013c7cc57777ae0ac", "getCurrentState")
   if rc == 0 and a == true then
      if b == 1 then
         table.insert(handlers, {name = "-"})
         table.insert(handlers, {name = "Show Continent Bigmap", func = function() Execute("bigmap on") end })
      elseif c == 1 then
         table.insert(handlers, {name = "-"})
         table.insert(handlers, {name = "Merge Continent Bigmap Into GMCP Mapper", func = function() Execute("bigmap merge") end })
      end
   end
      
   local t, tf = {}, {}
   for i, v in ipairs(handlers) do
      table.insert (t, v.name)
      if v.func then
         table.insert(tf, v)
      end
   end -- for
      
   local choice = WindowMenu (mapper.win, 
                        WindowInfo (mapper.win, 14), 
                        WindowInfo (mapper.win, 15), 
                        "!"..table.concat (t, "|"))
   
   if choice ~= "" then
      local f = tf[tonumber(choice)]
      if f then
         f.func(room, uid, f.param)
      end -- if handler found
   end                        
end -- room_click

auto_backup_count = tonumber(GetVariable("auto_backup_count")) or 0
function rotate_backups (manual)
   if (manual) then
      os.remove(firstBackup.."_Manual_oldest")
      os.remove(firstBackup.."_Manual_oldest.zip")
      os.rename(firstBackup.."_Manual_older", firstBackup.."_Manual_oldest")
      os.rename(firstBackup.."_Manual_older.zip", firstBackup.."_Manual_oldest.zip")
      os.rename(firstBackup.."_Manual_old", firstBackup.."_Manual_older")
      os.rename(firstBackup.."_Manual_old.zip", firstBackup.."_Manual_older.zip")
      os.rename(firstBackup.."_Manual", firstBackup.."_Manual_old")
      os.rename(firstBackup.."_Manual.zip", firstBackup.."_Manual_old.zip")
      ok, err = os.rename(firstBackup, firstBackup.."_Manual")
      ok, err = os.rename(firstBackup..".zip", firstBackup.."_Manual.zip")
   else
      auto_backup_count = auto_backup_count + 1
      local t = utils.readdir (firstBackup.."_Automatic*")
      local oldest_exists = false
      local olderer_exists = false
      local older_exists = false
      if t ~= nil then
         local oldest_string = sanitize_filename(WorldName())..".db.Backup_Automatic_oldest"
         local olderer_string = sanitize_filename(WorldName())..".db.Backup_Automatic_olderer"
         local older_string = sanitize_filename(WorldName())..".db.Backup_Automatic_older"
         for k,v in pairs(t) do
            if string.find(k,oldest_string) then
               oldest_exists = true
            elseif string.find(k,olderer_string) then
               olderer_exists = true
            elseif string.find(k,older_string) then
               older_exists = true
            end
         end
      end
      if not (oldest_exists and olderer_exists and older_exists) then
         auto_backup_count = 1
      end
      if oldest_exists == false or auto_backup_count == 84 then
         os.remove(firstBackup.."_Automatic_oldest")
         os.remove(firstBackup.."_Automatic_oldest.zip")
         os.rename(firstBackup.."_Automatic_olderer", firstBackup.."_Automatic_oldest")
         os.rename(firstBackup.."_Automatic_olderer.zip", firstBackup.."_Automatic_oldest.zip")
      end
      if oldest_exists == false or olderer_exists == false or auto_backup_count % 28 == 0 then
         os.remove(firstBackup.."_Automatic_olderer")
         os.remove(firstBackup.."_Automatic_olderer.zip")
         os.rename(firstBackup.."_Automatic_older", firstBackup.."_Automatic_olderer")
         os.rename(firstBackup.."_Automatic_older.zip", firstBackup.."_Automatic_olderer.zip")
      end
      if oldest_exists == false or olderer_exists == false or older_exists == false or auto_backup_count % 7 == 0 then
         os.remove(firstBackup.."_Automatic_older")
         os.remove(firstBackup.."_Automatic_older.zip")
         os.rename(firstBackup.."_Automatic_old", firstBackup.."_Automatic_older")
         os.rename(firstBackup.."_Automatic_old.zip", firstBackup.."_Automatic_older.zip")
      end
      os.remove(firstBackup.."_Automatic_old")
      os.remove(firstBackup.."_Automatic_old.zip")
      os.rename(firstBackup.."_Automatic", firstBackup.."_Automatic_old")
      os.rename(firstBackup.."_Automatic.zip", firstBackup.."_Automatic_old.zip")
      os.rename(firstBackup, firstBackup.."_Automatic")
      os.rename(firstBackup..".zip", firstBackup.."_Automatic.zip")
      if auto_backup_count == 84 then
         auto_backup_count = 1
      end

      SetVariable("auto_backup_count",auto_backup_count)
      SetVariable("last_auto_backup", os.time())
   end
end

function automatic_backup()
   if fighting_state == true then
      AddTimer("backup_timer", 0, 0, 5, "", timer_flag.Replace + timer_flag.Enabled + timer_flag.ActiveWhenClosed, "automatic_backup")
      print("Mapper database automatic backup delayed due to combat. Will try again in 5 seconds.")
   else
      AddTimer("backup_timer", 23, 59, 59, "", timer_flag.Replace + timer_flag.Enabled + timer_flag.ActiveWhenClosed, "automatic_backup")
      backup_databases(false)
   end
end

function manual_backup()
   backup_databases(true)
end

function sanitize_filename(str)
   str = string.gsub(str, "[^%w%s()_-]", "")
   return Trim(str)
end

function quote(str)
   return "\""..str.."\""
end

function checkDatabaseIntegrity(full_check, second_run)
   Note("CHECKING MAP DATABASE INTEGRITY")
   Repaint()
   -- If needed, force wal_checkpoint databases to make sure everything gets written out
   -- this is a harmless no-op if not using journal_mode=WAL
   dbCheckExecute("PRAGMA wal_checkpoint(FULL);")
   local integrityCheck = true
   local integrity_check_query = "PRAGMA quick_check;"
   if full_check then
      integrity_check_query = "PRAGMA integrity_check;"
   end
   for row in dbnrowsWRAPPER(integrity_check_query) do
      tprint(row)
      if row.integrity_check ~= "ok" then
         integrityCheck = false
      end
   end
   if integrityCheck == false and second_run ~= true then
      ColourNote("yellow", "red", "MAPPER DB INTEGRITY CHECK FAILED. REBUILDING INDEXES AND TRYING AGAIN.")
      dbCheckExecute("REINDEX")
      return checkDatabaseIntegrity(true, true)
   end
   if not integrityCheck then
      ColourNote("yellow", "red", "FAILED INTEGRITY CHECK. CLOSE MUSHCLIENT AND RESTORE A KNOWN GOOD DATABASE BACKUP IMMEDIATELY.")
      utils.msgbox("FAILED MAPPER DB INTEGRITY CHECK. CLOSE MUSHCLIENT AND RESTORE A KNOWN GOOD DATABASE BACKUP IMMEDIATELY.", "Error!", "ok", "!", 1)
      CorruptionAlert()
      return false
   end
   Note("MAP DATABASE INTEGRITY CHECK PASSED")
   if second_run then
      ColourNote("white", "blue", "WHEW! LUCKY!")
   end
   return true
end

function backup_databases(manual)
   performing_maintenance = true
   local success = false
   Note("PERFORMING "..((manual and "MANUAL") or "AUTOMATIC").." DATABASE BACKUP. DON'T TOUCH ANYTHING!")
   if not checkDatabaseIntegrity(true) then
      Note("ABORTING CURRENT BACKUP")
      if not compact_mode then Note("") end
      Repaint()   
      db = assert (sqlite3.open(worldPath..".db")) -- try to re-open the database anyway
      performing_maintenance = false
      satisfy_broadcast_queue()
      return
   end
   Note("BACKING UP DATABASE")
   Repaint()
   
   backupPath = GetInfo(66).."db_backups\\"..sanitize_filename(WorldName())
   firstBackup = backupPath..".db.Backup"
   local ffi
   if type(jit) == 'table' then
      ffi = require("ffi")
      ffi.cdef[[
      bool CreateDirectoryA(const char *lpPathName, void *lpSecurityAttributes);
      bool CopyFileA(const char* lpExistingFileName, const char * lpNewFileName, bool bFailIfExists);
      unsigned long GetLastError(void);
      ]]
      
      succ = ffi.C.CreateDirectoryA(GetInfo(66).."db_backups\\", nil)
      err_no = ffi.C.GetLastError()
   else
      succ, err_no = utils.shellexecute("cmd", "/C mkdir db_backups", GetInfo(66), "open", 0)
   end
   if succ == false and err_no ~= 183 and err_no ~= 127 then
      -- error
      ColourNote("yellow","red", "ERROR ("..err_no..") trying to CreateDirectory: "..GetInfo(66).."db_backups\\\n")
   else 
      -- successfully created the backup directory
      
      -- record when the backup occurs
      dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("backup_date"), fixsql(os.date("%b %d, %Y - %X"))))
      
      db:close() -- always close the database before copying
      
      -- make new backup
      if use_compression == 1 then

         -- use pushd/popd here because cd can't @!#($$# access UNC directory paths
         local n = GetInfo(66).."aard_package_temp_file.txt" -- temp file for catching os.execute output
         local execute_string = "pushd "..quote(GetInfo(66)).." & zip -j -v -T "..quote(firstBackup..".zip").." "..quote(worldPath..".db").." >"..quote(n).." 2>&1 & popd"
         os.execute(execute_string)
         -- It's not so simple to catch errors from os.execute, so just display the system output here
         local lines = {}
         for line in io.lines (n) do
            table.insert(lines,line)
         end
         os.remove (n) -- remove temp file

         if not lines[#lines] or not string.find(lines[#lines], "zip OK") then
            -- something went wrong with the compression
            -- we expect to see some lines with the last line showing a passing test
            ColourNote("yellow","red", "ERROR executing system command: "..execute_string.."\n")
            for i,v in ipairs(lines) do
               ColourNote("yellow","red",v) -- flaming output
            end
            -- failure
         else
            for i,v in ipairs(lines) do
               Note(v) -- less intense output
            end
            success = true
         end
      else 
         -- no compression, just copy
         if type(jit) == 'table' then
            succ = ffi.C.CopyFileA(worldPath..".db", firstBackup, false)
            err_no = ffi.C.GetLastError()
         else
            -- succ, err_no =  utils.shellexecute("cmd", "/C copy "..worldPath..".db "..firstBackup, "", "open", 0);
            local inp, outp, errmsg
            succ = false
            inp, errmsg, err_no = io.open(worldPath..".db", "rb")
            if err_no == nil then
               outp, errmsg, err_no = io.open(firstBackup, "wb")
               if err_no == nil then
                  local data = inp:read("*all")
                  outp:write(data)
                  outp:close()
                  inp:close()
                  succ = true
               end
            end
            if succ == false then
               ColourNote("yellow","red", "ERROR: "..errmsg)
            end
         end
         if succ == false then
            ColourNote("yellow","red", "ERROR ("..err_no..") trying to copy database from '"..worldPath..".db' to '"..firstBackup.."'")
         else
            success = true
         end
      end
   end
   
   if success then
      rotate_backups(manual) -- rotate backup folders (obviously)
      Note("FINISHED DATABASE BACKUP. YOU MAY NOW GO BACK TO MUDDING.")
   else
      Note("ABORTING BACKUP.")
      CorruptionAlert()
   end
   if not compact_mode then Note("") end
   db = assert (sqlite3.open(worldPath..".db")) -- re-open database 
   Repaint()
   performing_maintenance = false
   satisfy_broadcast_queue()
end

function CorruptionAlert()
   if not compact_mode then Note("") end
   Note("WARNING, PLEASE READ: https://github.com/fiendish/aardwolfclientpackage/wiki/GMCP-driven-world-mapper#database-corruption")
   Note("If the information there does not help you 100%, then try asking on the Tech channel and report this error to Fiendish by email.")
   if not compact_mode then Note("") end
end

-- ec, areaKeys = CallPlugin("b6eae87ccedd84f510b74714", "getkeyword", "The Broken Halls of Horath") puts "horath" into areaKeys
-- ec, areaKeys = CallPlugin("b6eae87ccedd84f510b74714", "getkeyword", "halls") puts "damned,horath,vanir" into areaKeys
function getkeyword(area)
   local keys = {}
   for row in dbnrowsWRAPPER(string.format("SELECT uid FROM areas WHERE name LIKE %s;", fixsql("%"..area.."%"))) do
      table.insert(keys,row.uid);
   end -- finding areas
   return table.concat(keys, ",")
end

function fix_exits_table_v7()
   -- The original database implementation for exits was naive and broken. We want to fix it up here.
   -- Unfortunately, sqlite requires a little dance of table dropping for this to happen.
   local level_column_exists = false
   for a in dbnrowsWRAPPER "PRAGMA table_info('exits')" do
      if a["name"] == "level" then
         level_column_exists = true
      end
   end
   
   local query = [[
   BEGIN TRANSACTION;
   
   ALTER TABLE exits RENAME TO exits_backup;
   
   CREATE TABLE exits (
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     TEXT    NOT NULL, -- exit from which room (in rooms table)
      touid       TEXT    NOT NULL, -- exit to which room (in rooms table)
      level       STRING  NOT NULL DEFAULT '0', -- minimum level to make use of this exit
      date_added  DATE,             -- date added to database
      PRIMARY KEY(fromuid, dir),
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
   );

   INSERT OR REPLACE INTO exits(dir,fromuid,touid,date_added]]..(((level_column_exists == false) and "") or ",level")..[[) SELECT dir, fromuid, touid, date_added]]..(((level_column_exists == false) and "") or ", level")..[[ FROM exits_backup;
   DROP TABLE exits_backup;
   CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
   CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
   COMMIT;
   ]]
   dbCheckExecute(query)
end

function remove_date_added_columns()
   print("---------------------------------------------------------")
   print("Removing date_added from exits table...")
   BroadcastPlugin (999, "repaint")
   drop_db_columns("exits", {"date_added"}, "PRIMARY KEY(fromuid, dir)")
   print("Removing date_added from rooms table...")
   BroadcastPlugin (999, "repaint")
   drop_db_columns("rooms", {"date_added", "roomid"}, "PRIMARY KEY(uid)")
   print("Removing date_added from areas table...")
   BroadcastPlugin (999, "repaint")
   drop_db_columns("areas", {"date_added", "areaid"}, "PRIMARY KEY(uid)")
   print("Removing date_added from bookmarks table...")
   BroadcastPlugin (999, "repaint")
   drop_db_columns("bookmarks", {"date_added", "id"}, "PRIMARY KEY(uid)")
   print("Removing date_added from environments table...")
   BroadcastPlugin (999, "repaint")
   drop_db_columns("environments", {"date_added", "environmentid"}, "PRIMARY KEY(uid)")
   print("---------------------------------------------------------")
   BroadcastPlugin (999, "repaint")
end

function drop_db_columns(db_table, drop_columns, extra_directives)
   local drop_columns_lookup = {}
   for _,v in ipairs(drop_columns) do
      drop_columns_lookup[v] = true
   end

   local columns_to_keep = {}
   local column_names = {}
   for a in dbnrowsWRAPPER("PRAGMA table_info('"..db_table.."')") do
      if drop_columns_lookup[a["name"]] == nil then
         table.insert(columns_to_keep, a)
         table.insert(column_names, a["name"])
      end
   end
   local columns_string = table.concat(column_names, ",")

   local query = "BEGIN TRANSACTION;\n"
   query = query.."CREATE TEMPORARY TABLE t1_backup(\n"
   for i,col in ipairs(columns_to_keep) do
      query = query..col["name"].." "..col["type"]..(col["notnull"] == 1 and " NOT NULL" or "")..(col["dflt_value"] ~= nil and (" DEFAULT "..col["dflt_value"]) or "")..",\n"
   end
   query = query..extra_directives..");\n"
   query = query.."INSERT INTO t1_backup SELECT "..columns_string.." FROM "..db_table..";\n"
   query = query.."DROP TABLE "..db_table..";\n"
   query = query.."CREATE TABLE "..db_table.."(\n"
   for i,col in ipairs(columns_to_keep) do
      query = query..col["name"].." "..col["type"]..(col["notnull"] == 1 and " NOT NULL" or "")..(col["dflt_value"] ~= nil and (" DEFAULT "..col["dflt_value"]) or "")..",\n"
   end
   query = query..extra_directives..");\n"
   query = query.."INSERT INTO "..db_table.." SELECT "..columns_string.." FROM t1_backup;\n" 
   query = query.."DROP TABLE t1_backup;\n"
   query = query.."COMMIT;"
   
   dbCheckExecute(query)
end

function OnPluginInstall ()
   SetVariable("backup_timer_enabled", GetVariable("backup_timer_enabled") or "1")
   last_auto_backup = tonumber(GetVariable("last_auto_backup")) or 0
  
   SetOption ("tool_tip_visible_time", 10000) -- prolong the tooltip display

   configs = {}  -- in case not found

   fonts = utils.getfontfamilies ()

   -- if not there already, add it
   if not fonts.Dina then
      AddFont (GetInfo (66) .. "\\Dina.fon")
   end -- if Dina not installed

   -- get saved configuration
   assert (loadstring (GetVariable ("configs") or "")) ()
  
   -- initialize mapper engine
   mapper.init {
      config = configs,            -- colours, timing etc.
      get_room = get_room,        -- get_room (uid) called to get room info
      show_help = OnHelp,         -- to show help
      room_click = room_click,    -- called on RH click on room square
      timing = show_timing,       -- want to see timing
      show_up_down = show_up_down,          -- want to follow up/down exits?
   } 
    
   -- open databases on disk 
   worldPath = GetInfo(66)..sanitize_filename(WorldName())

   db = assert (sqlite3.open(worldPath..".db"))
   db:busy_timeout(100)
      
   if not checkDatabaseIntegrity(true) then
      return
   end
  
   dbCheckExecute("PRAGMA journal_mode=WAL;")

   for row in dbnrowsWRAPPER("PRAGMA user_version") do
      db_user_version = row.user_version
   end

   if db_user_version < 12 then
      performing_maintenance = true
      DoAfterSpecial(3, "update_db_schema("..db_user_version..")",sendto.script)
   else
      after_update_check()
   end
end

function update_db_schema(db_user_version)
   SetScroll(-1)
   print("\nThe GMCP mapper database schema has been changed.\nYour map database will now be updated.\nThis process may take a while.\n")
   utils.msgbox ("The GMCP mapper database schema has been changed.\nYour map database will now be updated.\nThis process may take a while.", "", "ok", "i")

   -- Only go through the structure creation if we haven't done it already
   -- to save time at startup.
   if db_user_version < 2 then
      print("Updating mapper database schema to v2...")
      BroadcastPlugin (999, "repaint")
      create_tables()
      dbCheckExecute("PRAGMA user_version = 2;")
   end

   -- Database version 3 used to preload terrains, but now we dynamically
   -- request the terrains list from the server with sendgmcp request sectors
   -- se we don't need it anymore. Now we just skip from 2 to 4.

   if db_user_version < 4 then
      print("Updating mapper database schema to v4 (v3 skipped)...")
      BroadcastPlugin (999, "repaint")
      -- add bookmarks and terrain tables to the main db since we're
      -- ditching the second db file
      dbCheckExecute([[  
      CREATE TABLE IF NOT EXISTS bookmarks (
         id          INTEGER PRIMARY KEY AUTOINCREMENT,
         uid         TEXT    NOT NULL,   -- vnum of room
         notes       TEXT,               -- user notes
         date_added  DATE,               -- date added to database
         UNIQUE (uid)
      );
      CREATE TABLE IF NOT EXISTS terrain (
         id          INTEGER PRIMARY KEY AUTOINCREMENT,
         name        TEXT    NOT NULL,   -- terrain name
         color       INTEGER,            -- RGB code
         date_added  DATE,               -- date added to database
         UNIQUE (name)
      );
      ]])
      dbCheckExecute("PRAGMA user_version = 4;")
   end
   
   if db_user_version < 5 then
      print("Updating mapper database schema to v5...")
      BroadcastPlugin (999, "repaint")
      check_rooms_flags()
      dbCheckExecute("PRAGMA user_version = 5;")
   end

   if db_user_version < 6 then
      print("Updating mapper database schema to v6...")
      BroadcastPlugin (999, "repaint")
      -- original database name for wayhouse was missing the apostrophe
      dbCheckExecute([[
      update areas set name="The Adventurers' Wayhouse" where uid="wayhouse";
      ]])
      dbCheckExecute("PRAGMA user_version = 6;")
   end
   
   if db_user_version < 7 then
      print("Updating mapper database schema to v7...")
      BroadcastPlugin (999, "repaint")
      fix_exits_table_v7()
      dbCheckExecute([[
      CREATE TABLE IF NOT EXISTS storage (
         name        TEXT NOT NULL,
         data        TEXT NOT NULL,
         PRIMARY KEY (name)
      );
      ]])
      loadstring(GetVariable("bounce_recall") or "")()
      loadstring(GetVariable("bounce_portal") or "")()
      if bounce_recall then
         dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_recall"), fixsql(serialize.save("bounce_recall"))))
      end
      if bounce_portal then
         dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_portal"), fixsql(serialize.save("bounce_portal"))))
      end
      dbCheckExecute("PRAGMA user_version = 7;")
   end

   -- I guess we skipped over v8. No big deal.
   
   if db_user_version < 9 then
      print("Updating mapper database schema to v9 (v8 skipped)...")
      BroadcastPlugin (999, "repaint")
      local flags_column_exists = false
      for a in dbnrowsWRAPPER("PRAGMA table_info('areas')") do
         if a["name"] == "flags" then
            flags_column_exists = true
         end
      end
      if not flags_column_exists then
         dbCheckExecute("ALTER TABLE areas ADD COLUMN flags TEXT NOT NULL DEFAULT '';")
      end
      dbCheckExecute("PRAGMA user_version = 9;")
   end

   if db_user_version < 10 then
      print("Updating mapper database schema to v10...")
      BroadcastPlugin (999, "repaint")
      remove_date_added_columns()
      local ignore_exits_mismatch_column_exists = false
      for row in dbnrowsWRAPPER("PRAGMA table_info('rooms')") do
         if row["name"] == "ignore_exits_mismatch" then
            ignore_exits_mismatch_column_exists = true
         end
      end
      if not ignore_exits_mismatch_column_exists then
         dbCheckExecute("ALTER TABLE rooms ADD COLUMN ignore_exits_mismatch INTEGER NOT NULL DEFAULT 0;")
      end
      dbCheckExecute("PRAGMA user_version = 10;")
   end

   if db_user_version < 11 then
      print("Updating mapper database schema to v11...")
      BroadcastPlugin (999, "repaint")
      dbCheckExecute("CREATE INDEX IF NOT EXISTS exits_touid_index ON exits (touid);")
      dbCheckExecute("CREATE INDEX IF NOT EXISTS rooms_area_index ON rooms (area);")
   end

   if db_user_version < 12 then
      -- insert sad trombone here
      print("Updating mapper database schema to v12...")

      print("Removing unused indices...")
      BroadcastPlugin (999, "repaint")
      dbCheckExecute("DROP TABLE IF EXISTS rooms_lookup;")
      dbCheckExecute("DROP INDEX IF EXISTS exits_touid_index;")

      print("Removing more unused columns...")
      BroadcastPlugin (999, "repaint")
      drop_db_columns("terrain", {"date_added", "id"}, "PRIMARY KEY(name)") -- I can't believe I missed one. *sigh*
      drop_db_columns("rooms", {"x","y","z","building","notes"}, "PRIMARY KEY(uid)")

      print("Adding additional room colors stuff")
      BroadcastPlugin (999, "repaint")
      dbCheckExecute([[
         CREATE TABLE IF NOT EXISTS room_colors (
            roomid TEXT PRIMARY KEY,
            color INTEGER,
            color2 INTEGER,
            fillbrush INTEGER
         );
      ]])
      
      local column_exists = false
      for a in dbnrowsWRAPPER("PRAGMA table_info('terrain')") do
         if a["name"] == "color2" then
            column_exists = true
         end
      end
      if not column_exists then
         dbCheckExecute('ALTER TABLE terrain ADD COLUMN color2 INTEGER DEFAULT 0;')
      end
      column_exists = false
      for a in dbnrowsWRAPPER("PRAGMA table_info('terrain')") do
         if a["name"] == "fillbrush" then
            column_exists = true
         end
      end
      if not column_exists then
         dbCheckExecute('ALTER TABLE terrain ADD COLUMN fillbrush INTEGER DEFAULT 8;')
      end
      store_default_terrain_colors()
   end

   print("")
   print("Converted database to new format. Verifying integrity.")
   BroadcastPlugin (999, "repaint")
   if not checkDatabaseIntegrity(true) then
      return
   end
   dbCheckExecute("VACUUM;")
   print("")
   BroadcastPlugin (999, "repaint")
   dbCheckExecute("PRAGMA user_version = 12;")

   utils.msgbox ("Your map database schema update has completed.", "", "ok", "i")

   after_update_check()

   performing_maintenance = false
   satisfy_broadcast_queue()
end

-- color, color2, fillbrush
default_terrain_colors = {
   quicksand={32896,0,8},
   crossroad_ews={12632256,0,8},
   ocean={7346457,9124924,11},
   field3={2330219,0,8},
   bookshelves={12632256,0,8},
   hell2={2644685,0,8},
   road_eastwest={12632256,0,8},
   ship={12632256,0,8},
   lightning={12632256,0,8},
   chesswhite={16777215,0,8},
   ice={16775911,16777215,5},
   flowers2={12632256,0,8},
   bloodyroom={255,0,8},
   bookshelves_ns={12632256,0,8},
   forest={2263842,32768,8},
   areaexit={9109643,0,0},
   swamp={3107669,0,8},
   underground={5908803,0,8},
   vertical_shaft={12632256,0,8},
   cave={3538944,347760,9},
   tornado={8421504,0,8},
   volcano={255,0,12},
   Mudschool={12632256,0,8},
   city={16119285,12632256,8},
   road_crossroads={12632256,0,8},
   shore={11186720,7346457,11},
   sun={65535,0,8},
   office={8388736,0,8},
   flowers1={12632256,0,8},
   underwater={8388608,0,8},
   mountain={347760,0,12},
   hellfountain={255,0,8},
   waternoswim={11479080,0,7},
   crossroad_se={12632256,0,8},
   dungeon={8421504,0,9},
   mountain_cyan={8421376,0,12},
   redcarpet={255,0,8},
   rain={8421504,0,8},
   slashtwo={12632256,0,8},
   snow={16777215,14737632,8},
   hell4={255,0,8},
   crater={12632256,0,8},
   redgateway={12632256,0,8},
   hellhall={255,0,8},
   clanexit={12632256,0,8},
   mist={8421504,0,8},
   unused={12632256,0,8},
   rocks={32896,0,8},
   afountain={12632256,0,8},
   hut={12632256,0,8},
   ashen_field={32896,0,8},
   well={12632256,0,8},
   castle={14474460,0,7},
   desert={9234160,13882323,11},
   city_underground={8421504,0,8},
   wind1={12632256,0,8},
   hills={2263842,3329434,12},
   hell3={255,0,8},
   hellinside={255,0,8},
   hell1={2237106,0,8},
   rainbow={16776960,0,8},
   cloud2={8421504,0,8},
   aylorcity={12632256,0,8},
   beach={6333684,14745599,8},
   ocean4={8388608,14772545,12},
   dead_forest={32896,0,8},
   waterswim={16711680,0,8},
   fountain={8421376,0,8},
   archive={12632256,0,8},
   dead_jungle={32896,0,8},
   field4={32768,0,8},
   bloodyhall={255,0,8},
   ocean3={9109504,0,12},
   palace_room={12632256,0,8},
   air={16776960,0,8},
   crypt={8388608,0,8},
   crossroad_nw={12632256,0,8},
   ruins={12632256,0,8},
   interestpoint={12632256,0,8},
   jungle={32768,0,9},
   wind2={12632256,0,8},
   stairs={12632256,0,8},
   cloud3={12632256,0,8},
   lottery={12632256,0,8},
   dark={8421504,0,8},
   tunnel={12632256,0,8},
   temple={12632256,0,8},
   hallway={12632256,0,8},
   inside={12632256,0,8},
   dead_field={32896,0,8},
   field2={32768,0,8},
   chessblack={8388608,0,8},
   cloud1={12632256,0,8},
   dustdevil={12632256,0,8},
   alley={8421504,0,8},
   ocean2={7346457,9109504,4},
   slashfour={12632256,0,8},
   river={8388608,0,8},
   bridge={10526303,8388608,8},
   fiery_cave={12632256,0,8},
   slashone={12632256,0,8},
   slashthree={12632256,0,8},
   cabin={12632256,0,8},
   chaos_sea={12632256,0,8},
   redtemple={12632256,0,8},
   insideice={16777215,0,8},
   electric={12632256,0,8},
   graveyard={8421504,0,8},
   icehills={16770745,16119285,12},
   icemount={16774601,16777215,7},
   field={3107669,3329434,8},
   shop={32768,0,8},
   space3={8421504,0,8},
   space2={8421504,13882323,8},
   moon={14772545,0,8},
   space4={1973790,0,8},
   space1={0,0,0},
   plain={8573660,2332809,8},
   trail_ew={755384,8421504,8},
   pillar={12632256,0,4},
   smallroad={11119017,0,8},
   smallroad_ew={11119017,0,8},
   road={16119285,0,8}
}

function store_default_terrain_colors()
   for terrain,v in pairs(default_terrain_colors) do
      dbCheckExecute(string.format("INSERT OR REPLACE INTO terrain (name, color, color2, fillbrush) VALUES (%s, %d, %d, %d);", fixsql(terrain), v[1], v[2], v[3]))
   end
end

function after_update_check()
   b_b, err, erm = io.open(worldPath.."_bookmarks.db", "r")
   if b_b ~= nil then
      io.close(b_b)
      ColourNote("white", "blue", "Found obsolete bookmarks file "..sanitize_filename(WorldName()).."_bookmarks.db.")
      ColourNote("white", "blue", "Merging into the main database file.")
      ColourNote("white", "blue", sanitize_filename(WorldName()).."_bookmarks.db --> "..sanitize_filename(WorldName())..".db")
      db_bm = assert (sqlite3.open(worldPath.."_bookmarks.db"))

      local bm_found = false
      for row in db_bm:nrows("SELECT name FROM sqlite_master WHERE type='table' AND name='bookmarks';") do
         bm_found = true
      end
      local tr_found = false
      for row in db_bm:nrows("SELECT name FROM sqlite_master WHERE type='table' AND name='terrain';") do
         tr_found = true
      end
      if bm_found then
         for row in db_bm:nrows("SELECT * FROM bookmarks;") do
            dbCheckExecute(string.format("INSERT OR REPLACE INTO bookmarks (uid, notes) VALUES (%s, %s);",
            fixsql(row.uid),fixsql(row.notes)))
         end
      end
      if tr_found then
         for row in db_bm:nrows("SELECT * FROM terrain;") do
            dbCheckExecute(string.format("INSERT OR REPLACE INTO terrain (name, color) VALUES (%s, %i);",
            fixsql(row.name),row.color))
         end
      end
      
      db_bm:close()
      ok, err = os.remove(worldPath.."_bookmarks.db")
      if not ok then
         ColourNote("white","red", "Error trying to delete obsolete file: "..worldPath.."_bookmarks.db. Please delete it manually.")
      end
   end

   -- grab all area names
   for row in dbnrowsWRAPPER("SELECT * FROM areas") do
      area = {
         name = row.name,
         texture = row.texture,
         color = row.color,
         virtual = (row.flags:find("virtual") ~= nil)
      }
      mapper.areas[row.uid] = area
   end   -- finding areas
  
   -- grab all user terrain info
   for row in dbnrowsWRAPPER("SELECT * FROM terrain") do
      mapper.user_terrain_colour[row.name] = {color=row.color, color2=row.color2, fillbrush=row.fillbrush}
   end -- finding terrains
 
   -- grab all environment names
   for row in dbnrowsWRAPPER("SELECT * FROM environments") do
      environments [tonumber (row.uid)] = row.name
      terrain_colours [row.name] = tonumber (row.color)
   end -- finding environments
  
   --~    bounce_recall = {dir="home",uid=21335}
   --~    bounce_portal = {dir="enter",uid=26151}
   for row in dbnrowsWRAPPER("SELECT * FROM storage") do
      if row.name == "bounce_portal" or row.name == "bounce_recall" then
         loadstring(row.data or "")()
      end
   end

   local bounce_portal_orphaned = (bounce_portal ~= nil)
   local bounce_recall_orphaned = (bounce_recall ~= nil)
   if (bounce_portal_orphaned or bounce_recall_orphaned) then
      for row in dbnrowsWRAPPER(PORTALS_QUERY) do
         if (bounce_portal_orphaned and (row.dir==bounce_portal.dir)) then
            bounce_portal_orphaned = false
         end
         if (bounce_recall_orphaned and (row.dir==bounce_recall.dir)) then
            bounce_recall_orphaned = false
         end
      end
      if bounce_portal_orphaned then
         Note("Detected orphaned bounce portal.")
         map_bounceportal(nil, nil, {"clear"})
      end
      if bounce_recall_orphaned then
         Note("Detected orphaned bounce recall.")
         map_bouncerecall(nil, nil, {"clear"})
      end
   end
      
   -- if disabled last time, stay disabled
   if GetVariable ("enabled") == "false" then
      ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
      check (EnablePlugin(GetPluginID (), false))
      return
   end -- they didn't enable us last time

   OnPluginEnable()
   if not IsConnected() then
      OnPluginDisconnect()
   end
end -- OnPluginInstall

function OnPluginEnable()
   if not window_hidden then
      mapper.show()
   else
      Note("------ Your mapper is active but hidden. --------")
   end
   if IsConnected() then
      OnPluginConnect()
      Send_GMCP_Packet("request char")
      Send_GMCP_Packet("request room")
   end
   load_all_rooms()
   OnPluginSaveState()
end -- OnPluginEnable

-- hide window on removal
function OnPluginDisable ()
   OnPluginSaveState()
   mapper.hide()
   if IsConnected() then
      OnPluginDisconnect()
   end
end -- OnPluginDisable

function OnPluginClose ()
   -- if enabled
   if GetPluginInfo(GetPluginID(), 17) then
      OnPluginDisable()
   end -- if enabled
   WindowDelete(mapper.win)
end -- OnPluginClose

function OnPluginSaveState ()
   SetVariable ("window_hidden", window_hidden and "1" or "0")
   SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
   mapper.save_state ()
   SetVariable("config","") -- wipe out the old config table
   SetVariable("configs", "configs = " .. serialize.save_simple (mapper.config))
   SetVariable("quick_mode", quick_mode and "1" or "0")
   SetVariable("shownotes", shownotes and "1" or "0")
   SetVariable("compact_mode", compact_mode and "1" or "0")
   
   -- close and reopen database
   if db:isopen() then
      db:close()
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
end -- OnPluginSaveState
 
terrain_colours = {}

-- ANSI colours lookup (for terrain_colours)
colour_lookup = {
   [0] =   ColourNameToRGB  "black",  
   [1] =   ColourNameToRGB  "maroon", 
   [2] =   ColourNameToRGB  "green",  
   [3] =   ColourNameToRGB  "olive",  
   [4] =   ColourNameToRGB  "navy",   
   [5] =   ColourNameToRGB  "purple", 
   [6] =   ColourNameToRGB  "teal",   
   [7] =   ColourNameToRGB  "silver", 
   [8] =   ColourNameToRGB  "gray",   
   [9] =   ColourNameToRGB  "red",    
   [10] =  ColourNameToRGB  "lime",   
   [11] =  ColourNameToRGB  "yellow", 
   [12] =  ColourNameToRGB  "blue",   
   [13] =  ColourNameToRGB  "magenta",
   [14] =  ColourNameToRGB  "cyan",   
   [15] =  ColourNameToRGB  "white",  
} -- end of colour_lookup

running = false
function activate_running(run)
   running = run
   if not running then
      local area_exists = false
      for n in dbnrowsWRAPPER (string.format ("SELECT uid FROM areas where uid=%s", fixsql(gmcproom.area))) do
         area_exists = true
      end
      if not area_exists then
         Send_GMCP_Packet("request area")
      end
   else
     DeleteTimer("draw_fullarea")
   end
   mapper.draw(mapper.current_room)
end

function compareTables(primary, secondary)
   for i,v in pairs(primary) do
      if secondary[i] ~= v then
         return false
      end
   end
   return true
end

bigmap_override = false
function override_continents(override)
   if override == "true" then
      bigmap_override = true
   elseif override == "false" then
      bigmap_override = false
   end
   mapper.halt_drawing(bigmap_override and mapper.current_room_is_cont)
end

function manual_norecall(room_id, norecall)
   local room = get_room(room_id)
   if room ~= nil then 
      room.norecall = norecall
      save_room_to_database(room_id, room)
      Note("No-recall flag "..(norecall == 1 and "set on" or "removed from").." room "..room_id..".")
   else
      Note("NORECALL ERROR: Room "..room_id.." is not in the database.")
   end
end

function manual_noportal(room_id, noportal)
   local room = get_room(room_id)
   if room ~= nil then 
      room.noportal = noportal
      save_room_to_database(room_id, room)
      Note("No-portal flag "..(noportal == 1 and "set on" or "removed from").." room "..room_id..".") 
   else
      Note("NOPORTAL ERROR: Room "..room_id.." is not in the database.")
   end
end
function ignore_mismatch_toggle(room, room_id, ignore_exits_mismatch)
   ignore_mismatch(room_id, not ignore_exits_mismatch)
end

function ignore_mismatch(room_id, ignore_exits_mismatch)
   room_id = Trim(room_id)
   if room_id == "" then
      room_id = mapper.current_room
   end
   if room_id then
      local room = get_room(room_id)
      if room ~= nil then 
         room.ignore_exits_mismatch = ignore_exits_mismatch
         save_room_to_database(room_id, room)
         Note("Ignore exits mismatch flag "..(ignore_exits_mismatch and "set on" or "removed from").." room "..room_id..".") 
      else
         Note("IGNORE EXITS MISMATCH ERROR: Room "..room_id.." is not in the database.")
      end
   else
      Note("IGNORE EXITS MISMATCH ERROR: I do not know your room! Try typing 'LOOK' first, or pick a room.")
   end
end

flagType = nil
function mark_prison_flag()
   if (flagType ~= nil) and (room_at_bounceback ~= nil) and (rooms[room_at_bounceback] ~= nil) then
      if (mapper.current_room == room_at_bounceback) then
         if (flagType == "noportal") and (rooms[room_at_bounceback].noportal ~= 1) then
            Note('Marking room (', room_at_bounceback, ') noportal')
            rooms[room_at_bounceback].noportal = 1
         end
         if (flagType == "norecall") and (rooms[room_at_bounceback].norecall ~= 1) then
            Note('Marking room (', room_at_bounceback, ') norecall')
            rooms[room_at_bounceback].norecall = 1
         end
         dbCheckExecute("BEGIN TRANSACTION;")
         save_room_to_database(room_at_bounceback, rooms[room_at_bounceback])
         dbCheckExecute("COMMIT;")
      else
         print("You were moving too quickly (or moved while blind?) to safely flag your room as "..flagType..".")
      end
   end
   flagType = nil
end

function norecall_room()
   if (mapper.current_room ~= nil) and (rooms[mapper.current_room] ~= nil) and (rooms[mapper.current_room].norecall ~= 1) then
      flagType = "norecall"
      check_blindness()
   end
end

function noportal_room()
   if (mapper.current_room ~= nil) and (rooms[mapper.current_room] ~= nil) and (rooms[mapper.current_room].noportal ~= 1) then
      flagType = "noportal"
      check_blindness()
   end
end 

function check_blindness()
   room_at_bounceback = mapper.current_room
   print("Checking for blindness flag before marking this room "..flagType.."...")
   blinded = true
   Send_GMCP_Packet("request room")
   EnableTrigger("blindness_watch", true)
   SendNoEcho("aflags")
end

continent_zones = {["alagh"]=true,["abend"]=true,["gelidus"]=true,["mesolar"]=true,["southern"]=true,["uncharted"]=true,["vidblain"]=true}

function draw_other(name, line, wildcards)
   mapper.current_room = wildcards[1]
   local the_room = get_room(mapper.current_room)
   if not the_room then
      mapper.mapprint("No known room "..mapper.current_room)
      return
   end
   mapper.current_room_is_cont = continent_zones[the_room.area]
   mapper.halt_drawing(false)
   mapper.draw_fullarea()
end

lastarea = ""
function got_gmcp_room()
   local room_number = gmcpval("num")
   if not(room_number) then 
      return
   end
   
   if mapper.current_room_is_cont ~= (gmcpval("coord.cont") == "1") then
      mapper.current_room_is_cont = (gmcpval("coord.cont") == "1")
      mapper.halt_drawing(bigmap_override and mapper.current_room_is_cont)
   end
  
   gmcproom = {
      name = strip_colours(gmcpval("name")),
      area = gmcpval("zone"),
      terrain = gmcpval("terrain"),
      info = gmcpval("details"),
      exits = {},
      exit_locks = {}
      }
      
   if gmcproom.area ~= lastarea then
      lastarea = gmcproom.area
      -- purge all virtual areas except the current area
      for k,v in pairs(mapper.areas) do
         if v.virtual and (k ~= gmcproom.area) then
            purgezone(k)
         end
      end
   
      if not running then
         local area_exists = false
         for n in dbnrowsWRAPPER (string.format ("SELECT uid FROM areas where uid=%s", fixsql(gmcproom.area))) do
            area_exists = true
         end
         if not area_exists then
            Send_GMCP_Packet("request area")
         end
      end
   end

   -- Try to accomodate closed clan rooms and other nomap rooms.
   -- We'll have to make some other changes elsewhere as well.
   if room_number == "-1" then
      room_number = "nomap_"..gmcproom.name.."_"..gmcproom.area
   end
   
   mapper.current_room = room_number
   local room = get_room(room_number)

   if shownotes and room and room.notes and room.notes ~= "" then
      for _,v in ipairs(ColoursToStyles("*** MAPPER NOTE *** -> "..room.notes.."@w\n\n", "x033")) do
         ColourTell(RGBColourToName(v.textcolour), RGBColourToName(v.backcolour), v.text)
      end
   end

   -- re-save if we got information that is different than before
   local same_exits = ((room and compareTables(gmcpdata.exits, room.exits)) or false)
   if room and room.ignore_exits_mismatch and not same_exits then
      same_exits = true
      Note("(This room has exits that don't match the MUD, but you've chosen to ignore it.)")
   end
   local same_area = ((room and (nilToStr(room.area) == nilToStr(gmcproom.area))) or false)
   if not room or nilToStr(room.name) ~= nilToStr(gmcproom.name) or
                  nilToStr(room.terrain) ~= nilToStr(gmcproom.terrain) or
                  nilToStr(room.info) ~= nilToStr(gmcproom.info) or
                  same_area == false or
                  same_exits == false then
      if same_area then
--          print("same area")
--          if room then 
--             print("ROOM")
--             tprint(room) 
--          end
--          print("GMCPROOM")
--          tprint(gmcproom)
         
         gmcproom.exits = (room.exits or {})
         gmcproom.exit_locks = (room.exit_locks or {})
         gmcproom.noportal = (room.noportal or 0)
         gmcproom.norecall = (room.norecall or 0)
      elseif room and nilToStr(room.area) ~= "" and mapper.areas[nilToStr(room.area)] then
         -- replacement area
--         print("different area")
--         if room then 
--            print("ROOM")
--            tprint(room) 
--         end
--         print("GMCPROOM")
--         tprint(gmcproom)

         mapper.mapprint("This room has moved areas. You should 'mapper purgezone "..nilToStr(room.area).."' if this new area replaces it.")
         map_purgeroom (nilToStr(room_number), gmcproom.area)
      else
         -- brand new area
--         print("new area")
         gmcproom.exits = {}
         gmcproom.exit_locks = {}
         gmcproom.noportal = 0
         gmcproom.norecall = 0
      end
      dbCheckExecute("BEGIN TRANSACTION;")
      save_room_to_database(room_number, gmcproom)
      rooms[room_number] = gmcproom
      if not same_exits or not same_area then
         save_room_exits(room_number)
      end
      dbCheckExecute("COMMIT;")   
   end -- if room not there
  
   mapper.draw(room_number)
end

function update_gmcp_area()

   local areaid = gmcpval("id")
   local areaname = gmcpval("name")
   local texture = gmcpval("texture")
   local color = gmcpval("col")
   local x,y,z = gmcpval("x"),gmcpval("y"),gmcpval("z")
   local flags = gmcpval("flags") or ""

   local q = string.format (
      "REPLACE INTO areas (uid, name, texture, color, flags) VALUES (%s, %s, %s, %s, %s);",
      fixsql (areaid), 
      fixsql (areaname),
      fixsql (texture),
      fixsql (color),
      fixsql (flags)
   )

   if show_database_mods then
      mapper.mapprint(q)
   end

   dbCheckExecute (q)

   mapper.areas[areaid] = {
      name = areaname,
      texture = texture,
      color = color,
      virtual = (flags:find("virtual") ~= nil)
   }

   Send_GMCP_Packet("request room") -- Just got a new area update. Now check for our room again.
end

function save_room_exits(uid) 
   if rooms[uid] == nil then
      return
   end
   if gmcpdata.exits ~= nil then
      for dir,touid in pairs(gmcpdata.exits) do
         if dir then
            dbCheckExecute (string.format ([[
               INSERT OR REPLACE INTO exits (dir, fromuid, touid) 
               VALUES (%s, %s, %s);
               ]], fixsql  (dir),  -- direction (eg. "n")
               fixsql  (uid),  -- from current room
               fixsql  (touid) -- destination room 
            ))

            if show_database_mods then
               mapper.mapprint ("Added exit: ", dir, "from room: ",uid, "to room: ", touid, " to database.")
            end -- if

            if rooms[uid].exits[dir] ~= touid then
               rooms[uid].exit_locks[dir] = "0"
            end
            rooms[uid].exits[dir] = touid
         else
            mapper.maperror ("Cannot make sense of:", exit)
         end -- if can decode    
      end -- for each exit
   end -- have exits.
end -- save_room_exits

function update_gmcp_sectors()
   requesting_sectors = false
   dbCheckExecute("BEGIN TRANSACTION;")
   dbCheckExecute ("DELETE FROM environments;")
   for i,v in pairs(gmcp_sectors_list.sectors) do
      dbCheckExecute( string.format([[
      INSERT OR REPLACE INTO environments VALUES (%s,%s,%d);
      ]], v.id, fixsql(v.name), v.color))
      dbCheckExecute( string.format([[
      INSERT OR IGNORE INTO terrain (name, color) VALUES (%s, %d);
      ]], fixsql(v.name), colour_lookup[tonumber(v.color)] or 0))
   end
   dbCheckExecute("COMMIT;")
   
   for row in dbnrowsWRAPPER("SELECT * FROM environments") do
      environments [tonumber (row.uid)] = row.name
      terrain_colours [row.name] = tonumber (row.color)
   end -- finding environments

   for row in dbnrowsWRAPPER("SELECT * FROM terrain") do
      mapper.user_terrain_colour[row.name] = {color = row.color, color2 = row.color2, fillbrush = row.fillbrush}
   end -- finding environments
   
   mapper.draw(mapper.current_room)
end

broadcast_queue = {}
function queue_broadcast(msg, id, name, text)
   table.insert(broadcast_queue, {["msg"]=msg, ["id"]=id, ["name"]=name, ["text"]=text})
end

function satisfy_broadcast_queue()
   for i,v in ipairs(broadcast_queue) do
      OnPluginBroadcast(v.msg, v.id, v.name, v.text)
   end
   broadcast_queue = {}
end

function OnPluginBroadcast (msg, id, name, text)
   if id == "3e7dedbe37e44942dd46d264" then -- gmcphandler
      if performing_maintenance == true then
         queue_broadcast(msg, id, name, text)
         return
      end

      if (text == "room.info") then
         blinded = false
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         local full_gmcp_room_elapsed = utils.timer()
         got_gmcp_room()
         if show_timing then
            print("Full room processing elapsed:",utils.timer()-full_gmcp_room_elapsed)
         end
      end -- if room.info

      if (text == "room.wrongdir") then
--         catch bumps here
      end -- wrongdir

      if (text == "char.base") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         mytier = tonumber(gmcpdata.tier)
      end

      if (text == "char.status") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         mylevel = tonumber(gmcpdata.level)
         myState = tonumber(gmcpdata.state)
         if running == false and myState == 12 then
            activate_running(true)
         elseif running == true and myState ~= 12 then
            activate_running(false)
         end
         if myState == 8 then
            fighting_state = true
         else
            fighting_state = false
         end
      end -- running
    
      if (text == "room.area") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.area")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         update_gmcp_area()
      end
      
      if (text == "room.sectors") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.sectors")
         luastmt = "gmcp_sectors_list = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         update_gmcp_sectors()
      end
   elseif (id == "462b665ecb569efbf261422f" and msg==996 and text == "re-register z") then
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", mapper.win)
   end
end

function quick_mode_toggle(name, line, wildcards)
   if (wildcards[2] ~= "") then
      quick_mode = (wildcards[2] == "on")
   end
   if not compact_mode then Note("") end
   if quick_mode then
      Note("QUICKLIST is ON: Lists of found targets will display immediately without sorting by distance.")
   else
      Note("QUICKLIST is OFF: Lists of found targets will pathfind each result and sort them by distance.")
   end
   if not compact_mode then Note("") end
end

function shownote_toggle(name, line, wildcards)
   if (wildcards[2] ~= "") then
      shownotes = (wildcards[2] == "on")
   end
   if not compact_mode then Note("") end
   if shownotes then
      Note("SHOWNOTES is ON: Notes added to rooms will display automatically upon entrance.")
   else
      Note("SHOWNOTES is OFF: Notes added to rooms will NOT display automatically.")
   end
   if not compact_mode then Note("") end
end

function compact_mode_toggle(name, line, wildcards)
   if (wildcards[2] ~= "") then
      compact_mode = (wildcards[2] == "on")
   end
   if not compact_mode then Note("") end
   if compact_mode then
      Note("COMPACT is ON: Mapper output won't display blank lines. Please report any that might show.")
   else
      Note("COMPACT is OFF: Mapper output will display blank lines (default behaviour).")
   end
   if not compact_mode then Note("") end
end

function map_area (name, line, wildcards)

   uid = mapper.current_room

   -- check we got room at all
   if not uid then
      print("I do not know your room! Try typing 'LOOK' first.")
      return
   end -- if

   -- look it up
   local ourroom = get_room(uid)

   if not ourroom then
      print("AREA ERROR: The area has not been initialized yet. Please try again in a second.")
      return
   end -- if

   local area = rooms[uid].area

   local rooms = {}
   
   local key = Trim(wildcards[1])
   local name = "%"..key.."%"
   if string.sub(key,1,1) == "\"" and string.sub(key,-1) == "\"" then
      name = Trim(string.sub(key,2,-2))
   end
   for row in dbnrowsWRAPPER(string.format ("SELECT uid, name, area FROM rooms WHERE trim(name) LIKE %s and area = %s", fixsql(name), fixsql(area))) do
      table.insert(rooms,{uid=row.uid, reason=true})
   end   -- finding room

   -- see if nearby

   mapper.find (name,
      rooms,
      false,       -- don't auto-walk
      quick_mode
   )

end -- map_area


function map_find (name, line, wildcards, quick_mode_force)

   local rooms = {}

   -- find matching rooms using FTS3
   local name = "%"..wildcards[1].."%"

   if string.sub(wildcards[1],1,1) == "\"" and string.sub(wildcards[1],-1) == "\"" then
      name = string.sub(wildcards[1],2,-2)
   end
   for row in dbnrowsWRAPPER(string.format ("SELECT uid, name FROM rooms WHERE name LIKE %s order by name", fixsql (name))) do
      table.insert(rooms, {uid=row.uid, reason=true})
   end   -- finding room
   
   -- see if nearby
   mapper.find (name,
      rooms,
      false,       -- don't auto-walk
      quick_mode_force or quick_mode
   )
end -- map_find


function map_find_special(which_ones, which_area)
   local wanted_items = {}
   for _, v in ipairs (which_ones) do 
      wanted_items [v:lower ()] = true 
   end
            
   local rooms = {}
  
   res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
   luastmt = "gmcpdata = " .. gmcparg
   assert(loadstring (luastmt or "")) ()
   local current_area = gmcpval("zone")

   area = Trim(which_area or "")
   if area == "" then
      mapper.mapprint("Searching all areas")
      query = "SELECT uid, name, info FROM rooms WHERE rooms.info IS NOT NULL"
   else
      if area == "here" then
         area = current_area
         mapper.mapprint("Searching current area")
      else
         area = "%"..area.."%"
         mapper.mapprint("Searching areas that partially match %"..area.."%")
      end
      query = string.format("SELECT uid, name, info FROM rooms WHERE rooms.info IS NOT NULL AND lower(rooms.area) LIKE %s", fixsql(area))
   end -- if area

   -- build table of special places (with info in them)
   for row in dbnrowsWRAPPER(query) do
      if row.info ~= "" then
         local wanted = false
         local t = {}
         for item in string.gmatch (row.info, "[^,]+") do
            if wanted_items [item:lower ()] then 
               wanted = true
               table.insert (t, capitalize (item))
            end -- if
         end -- for
         if wanted then
            table.insert(rooms, {uid=row.uid, reason=table.concat(t, ", ")})
         end -- if
      end -- if
   end   -- finding room
  
   -- find such places
   mapper.find (table.concat(which_ones,","),
      rooms,
      false,       -- don't auto-walk
      true         -- quick list
   )
end -- map_find_special

function map_shops (name, line, wildcards)
   map_find_special ({ "shop", "bank", }, wildcards[1])
end -- map_shops

function map_trainers (name, line, wildcards)
   map_find_special ({ "trainer", }, wildcards[1])
end -- map_trainers

function map_quests (name, line, wildcards)
   map_find_special ({ "questor", }, wildcards[1])
end -- map_quests

function map_healers (name, line, wildcards)
   map_find_special ({ "healer", }, wildcards[1])
end -- map_healers


function map_goto (name, line, wildcards)
   local dest = mapper.verify_search_target(wildcards[1], line)
   local walk_only = string.match(line, "^mapper walkto") ~= nil
   mapper.goto(dest, walk_only)
end -- map_goto

function map_where (name, line, wildcards)
   local srcstr = wildcards[2] and wildcards[1] or mapper.current_room
   local deststr = wildcards[2] or wildcards[1]
   local src = mapper.verify_search_target(srcstr, line)
   local dest = mapper.verify_search_target(deststr, line)
   
   if not src or not dest or not mapper.check_we_can_find() then
      return
   end

   if src == dest then
      mapper.mapprint("Start and end rooms are the same.")
      return
   end

   local elapsed = utils.timer()

   local foundpath = mapper.findpath(src, dest)

   if foundpath == nil then
      mapper.mapprint (string.format ("Path from %s to %s could not be found.", src, dest))
      return
   end
    
   local speedwalk = mapper.build_speedwalk(foundpath)
   
   if show_timing then
      print("Findpath elapsed:", utils.timer()-elapsed)
   end

   mapper.mapprint (string.format ("Path from %s to %s is:\n%s", (src == mapper.current_room) and "you" or src, dest, speedwalk))
end -- map_where

function map_resume (name, line, wildcards)
   if not mapper.last_speedwalk_uid then
      mapper.mapprint("No outstanding speedwalks or hyperlinks.")
      return
   end -- nothing to do
   
   mapper.goto(mapper.last_speedwalk_uid)
end -- map_resume

function map_notes (name, line, wildcards)
   local rooms = {}
   local area = Trim(wildcards[2] or "")

   local q = string.format ("SELECT bookmarks.uid as uid, bookmarks.notes as notes FROM bookmarks")

   if area == "room" or area == "thisroom" then
      if not mapper.current_room then
         mapper.mapprint("I don't know where you are right now - try: LOOK")
         return
      else
         mapper.mapprint("Searching the current room")
         q = q..",rooms where bookmarks.uid=rooms.uid and rooms.uid="..fixsql(mapper.current_room)
      end
   else
      if area ~= "" then
         if area == "here" then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
            luastmt = "gmcpdata = " .. gmcparg
            assert(loadstring (luastmt or "")) ()
            area = gmcpval("zone")
            mapper.mapprint("Searching the current area")
         else
            mapper.mapprint("Searching areas that partially match '"..area.."'")
            area = "%"..area.."%"
         end
         q = q..",rooms where bookmarks.uid=rooms.uid and rooms.area like "..fixsql(area)
      else
         mapper.mapprint("Searching all areas")
      end
   end
   
   -- build table of special places (with info in them)
   for row in dbnrowsWRAPPER(q) do
      table.insert(rooms,{uid=row.uid, reason=row.notes})
   end   -- finding room
  
   -- find such places
   mapper.find ("[NOTE]",
      rooms,
      false,        -- don't auto-walk
      true  -- quick list
   )
end -- map_notes

function toggleBackups(on, quiet)
   if on then
      EnableTimer("backup_timer", true)
      if not quiet then Note("Automated map database backup enabled.") end
      if ((os.time()-last_auto_backup) >= 86401) then
         Note("It looks like it has been more than 24 hours since your last automatic mapper database backup!")
         Note("Forcing an automatic backup now...")
         if not compact_mode then Note("") end
         Repaint()
         automatic_backup()
      end
   else
      EnableTimer("backup_timer", false)
      if not quiet then Note("Automated map database backup disabled.") end
   end
end

function OnPluginConnect ()
   if not db:isopen() then
      Note("GMCP Mapper: Reconnected; opening map database.")
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
   if GetVariable("backup_timer_enabled") == "1" then
      if (os.time()-last_auto_backup) < 86401 then
         local seconds = 86400-(os.time()-last_auto_backup)
         local hours = math.floor(seconds/3600)
         seconds = seconds - hours*3600
         local minutes = math.floor(seconds/60)
         seconds = math.floor(seconds - minutes*60)
         -- replace the timer with a new one that has the right time
         AddTimer("backup_timer", hours, minutes, seconds, "", timer_flag.Replace + timer_flag.Enabled + timer_flag.ActiveWhenClosed + timer_flag.OneShot, "automatic_backup")
      end
      toggleBackups(true, true)
   end
   Send_GMCP_Packet("rawcolor on")
end -- OnPluginConnect

sent_busy = false
function OnPluginDisconnect ()
   if sent_busy then
      BroadcastPlugin(999, "ok_you_can_go_now")
      sent_busy = false
   end
   if db:isopen() then
      Note("GMCP Mapper: Disconnected; closing map database.")
      db:close()
   end
   if GetVariable("backup_timer_enabled") == "1" then
      toggleBackups(false, true)
   end
end -- OnPluginConnect

function OnHelp (name, line, wildcards)
   local help_header = "                              [GMCP Mapper Help]"

   local help_index = [[
                           Mapper Help Index
=============================================================================
 mapper help               --> Show this list
 mapper help all           --> Show the entire list of all mapper commands
-----------------------------------------------------------------------------
 mapper help config        --> Commands for configuring the mapper
 mapper help exits         --> Commands for managing exits
 mapper help portals       --> Commands for managing portals
 mapper help searching     --> Commands for finding rooms
 mapper help exploring     --> Commands to aid exploring
 mapper help moving        --> Commands for moving between rooms
 mapper help utils         --> Other utilitarian commands
 mapper help search <txt>  --> Searches through help lines looking for a
                               particular word or phrase.
=============================================================================
]]
   local help_table = {
   ['config'] = {
['header'] = [[===== CONFIGURATION =============>]],
[[mapper quicklist [on/off]      --> ON will cause search results to display much
                                 > faster, but the results will not be sorted
                                 > by distance (default is on)]],
[[mapper shownotes [on/off]      --> ON will cause any notes in a room to display
                                 > automatically upon entering (default is on)]],
[[mapper compact [on/off]        --> ON will make it so no blank lines are
                                 > displayed by the mapper (default is off)]],
[[mapper backups <off/on>        --> Turn off or on automatic database backups
                                 > The default setting is on]],
[[mapper backups [un]compressed  --> Turn off or on database backup compression
                                 > The default setting is uncompressed (off)]],
[[mapper help                    --> This help
                                 > (or click the "?" button on the top right)]],
[[mapper zoom out                --> Zoom out]],
[[mapper zoom in                 --> Zoom in]],
[[mapper hide                    --> Hide map]],
[[mapper show                    --> Show map]],
[[mapper updown                  --> Toggle up/down exit drawing]]
},

   ['utils'] = {
['header'] = [[===== UTILITIES =================>]],
[[mapper backup                  --> Create new archived backup of your map
                                 > database in a db_backups directory,
                                 > preserving a few prior backups]],
[[mapper addnote                 --> Add a new note to the current room]],
[[mapper addnote <note>          --> Ditto, but skips the dialog]],
[[mapper purgezone <area>        --> Remove an area from the map database]],
[[mapper purgeroom               --> Purge the current room from the map database]],
[[mapper ignore mismatch <true/false> --> Don't overwrite the room in the database
                                      > if only the exits are "wrong"]]
},

   ['exits'] = {
['header'] = [[===== EXIT ACTIONS ==============>]],
[[mapper cexits                  --> List known custom exits]],
[[mapper cexits <here/area>      --> List known custom exits only in this or
                                 > another area]],
[[mapper cexit <command>         --> Follow and link a custom exit
                                 > (ex: 'mapper cexit ride bucket')
                                 > To insert a pause during execution
                                 > of the cexit, use wait(<seconds>) as one
                                 > or more of the cexit moves
                                 > To stack commands use ;; as separator
                                 > to get around the line break parser
                                 > (ex: 'mapper cexit open south;;south')]],
[[mapper delete cexits           --> Remove the custom exits from this room]],
[[mapper purge cexits            --> Remove all custom exits]],
[[mapper cexit_wait <seconds>    --> Wait the given number of seconds instead of
                                 > the standard 2 when constructing the next
                                 > cexit (between 2 and 30)]],
[[mapper lockexit                --> Bring up the exit level-locking dialog
                                 > for the current room.]]
},

   ['portals'] = {
['header'] = [[===== PORTAL ACTIONS ============>]],
[[mapper portal <command>        --> Link a special custom exit to the current 
                                 > room from everwhere else. Used for hand-held
                                 > portals and other teleporting commands.
                                 > To stack commands use ;; as separator
                                 > to get around the line break parser.
                                 > (ex: 'mapper portal hold amulet;;enter')]],
[[mapper portals                 --> List known mapper portals.
                                 > Recall-flagged portals (below) show in red]],
                                 [[]],
[[There is also 'mapper fullportal {<command>} {<room_id>} <level>' which lets
you set all portal aspects in one command without being in the target room.]],
[[]],
[[+---- NORECALL/NOPORTAL ROOM ASSISTANCE -------------------------------------+]],
[[mapper portalrecall <index>    --> Flag/unflag a portal as using a recall or
                                 > home command, to avoid using it in
                                 > identified norecall rooms.
                                 > Find the indices with 'mapper portals']],
[[mapper bounceportal <index>    --> Specifies which non-recall mapper portal
                                 > to bounce through when the path calculation
                                 > wants to recall or home from a
                                 > portal-friendly norecall room. For this to
                                 > work properly you must indicate which mapper
                                 > portals use recall or home with the 
                                 > portalrecall command listed above.
                                 > Find the indices with 'mapper portals']],
[[mapper bouncerecall <index>    --> Specifies which home/recall mapper portal
                                 > to bounce through when the path calculation
                                 > wants to portal from a recall-friendly
                                 > noportal room.
                                 > Find the indices with 'mapper portals']],
[[mapper bounceportal            --> Display the current bounce portal]],
[[mapper bouncerecall            --> Display the current bounce recall]],
[[mapper bounceportal clear      --> Clear the current bounce portal]],
[[mapper bouncerecall clear      --> Clear the current bounce recall]],
[[+----------------------------------------------------------------------------+]],
[[mapper noportal <id> [true/false] --> Manually set noportal flag]],
[[mapper norecall <id> [true/false] --> Manually set norecall flag]],
[[+----------------------------------------------------------------------------+]],
[[]],
[[mapper portallevel <ind> <lvl> --> Change the level lock on a stored portal
                                 > Find the indices with 'mapper portals'
                                 > Do not manually account for tiers]],
[[mapper delete portal <command> --> Remove the specified hand-held portal alias]],
[[mapper delete portal #<index>  --> Remove a hand-held portal by its index
                                 > Find the indices with 'mapper portals']],
[[mapper purge portals           --> Remove all hand-held portal aliases]]
},

   ['searching'] = {
['header'] = [[===== SEARCHING =================>]],
[[mapper find <text>             --> Room name search across whole database]],
[[mapper area <text>             --> Room name search limited to your zone]],
[[mapper list <text>             --> Like mapper find with quicklist mode on]],
[[]],
[[mapper notes                   --> Show rooms with notes]],
[[mapper notes <here/area>       --> Ditto, restricted to area]],
[[mapper shops                   --> Show all shops/banks]],
[[mapper shops <here/area>       --> Ditto, restricted to area]],
[[mapper train                   --> Show all trainers]],
[[mapper train <here/area>       --> Ditto, restricted to area]],
[[mapper quest                   --> Show all quest-givers]],
[[mapper quest <here/area>       --> Ditto, restricted to area]],
[[]],
[[mapper next                    --> Visit the next room in the most recent
                                 > list of results.]],
[[mapper next <index>            --> Ditto, but skip to the given result index.]],
[[mapper where <room id>         --> Show directions to a room number]]
},

   ['exploring'] = {
['header'] = [[===== EXPLORING =================>]],
[[mapper thisroom                --> Show details about the current room]],
[[mapper showroom <room id>      --> Draw the map as if you were standing in
                                 > a different room]],
[[mapper areas                   --> Show a list of all mapped areas]],
[[mapper areas <name>            --> Show a list of mapped areas partially
                                 > matching <name>]],
[[mapper unmapped                --> List unmapped exit counts for known areas]],
[[mapper unmapped <here/area>    --> List unmapped exits in this or another area]]
},

   ['moving'] = {
['header'] = [[===== MOVING ====================>]],
[[mapper goto <room id>          --> Run to a room by its room number]],
[[mapper walkto <room id>        --> Run to a room by its room number without 
                                 > using any mapper portals]],
[[mapper resume                  --> Initiate a new run to the previous target]]
}
}

   local function show_help(helps)
      print("")
      print(helps['header'])
      print("")
      for i,v in ipairs(helps) do
         print(v)
      end
   end

   print("")
   print(help_header)
   print("+---------------------------------------------------------------------------+")
   badnews = true
   if wildcards and wildcards[2] ~= "" then
      badnews = false
      if wildcards[2] == "all" then
         show_help(help_table['config'])
         show_help(help_table['exits'])
         show_help(help_table['portals'])
         show_help(help_table['searching'])
         show_help(help_table['exploring'])
         show_help(help_table['moving'])
         show_help(help_table['utils'])
      elseif wildcards[2] == "config" then
         show_help(help_table['config'])
      elseif wildcards[2] == "exits" then
         show_help(help_table['exits'])
      elseif wildcards[2] == "portals" then
         show_help(help_table['portals'])
      elseif wildcards[2] == "searching" then
         show_help(help_table['searching'])
      elseif wildcards[2] == "exploring" then
         show_help(help_table['exploring'])
      elseif wildcards[2] == "moving" then
         show_help(help_table['moving'])
      elseif wildcards[2] == "utils" then
         show_help(help_table['utils'])
      elseif wildcards[2]:find("search ") == 1 then
         local st, en = wildcards[2]:find("search ")
         local pattern = Trim(wildcards[2]:sub(en+1))
         local lowerPattern = pattern:lower()
         ColourTell("cornflower","black","Searching help for: ")         
         ColourNote("red","black",lowerPattern)
         if pattern ~= "" then
            for k,v in pairs(help_table) do
               local done_header = false
               for j,w in ipairs(v) do
                  local lowerW = w:lower()
                  if (w ~= "") and (w:find("--------",nil,true) == nil) and (lowerW:find(lowerPattern) ~= nil) then
                     if not done_header then
                        print("")
                        print(v['header'])
                        done_header = true
                     end
                     print("")
                     local wtable = lowerW:split(lowerPattern)
                     local marker = 1
                     for i,v in ipairs(wtable) do
                        ColourTell("cornflower","black",v)
                        if (i < #wtable) then
                           ColourTell("red", "black", w:sub(marker+#v, marker+#v+#pattern - 1))
                        end
                        marker = marker + #v + #pattern
                     end
                     Note("")
                  end
               end
            end
         else
            badnews = true
         end
      else
         badnews = true
      end
   end
   if badnews then
      print("")
      mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
      print("")
      print(help_index)
   end
   print("")
   print("+---------------------------------------------------------------------------+")
   print("")
end

require "checkplugin"
function OnPluginListChanged ()
   do_plugin_check_now ("abc1a0944ae4af7586ce88dc", "aard_repaint_buffer") -- check we have the repaint buffer plugin
   do_plugin_check_now ("3e7dedbe37e44942dd46d264", "aard_GMCP_handler")    -- check we have GMCP plugin
   do_plugin_check_now ("462b665ecb569efbf261422f", "aard_miniwindow_z_order_monitor") -- check we have z order plugin
end -- OnPluginListChanged

function nilToStr(n)
   return (((n ~= nil) and tostring(n)) or "")
end

function getmemoryusage()
  collectgarbage('collect')
  return collectgarbage('count')
end

]]>
</script>
</muclient>

