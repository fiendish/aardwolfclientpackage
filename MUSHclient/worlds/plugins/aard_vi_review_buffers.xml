<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- 
	 Thanks to the original authors
	of the code for the history buffers Tyler S, Oriol G, Wyoun for their contributions!
-->

<muclient>
<plugin
   name="Aardwolf_VI_Review_Buffers"
   author="Pwar"
   id="6000a4c6f0e71d31fecf523d"
   language="Lua"
	purpose="Allow for easy review of various messages/events sorted into categories with hotkeys"
   date_written="2017-12-17 13:00:25"
   requires="4.51"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[

Shortcut keys:

Alt + Right and Alt + Left - selects next and previous categorey

Shift + Alt + Right and Left - moves category in direction

Ctrl + 1 through Ctrl + 0 - reviews last 10 messages
	double pressing the number will copy to clipboard
	
Alt + 1 through Alt + 0 - reviews message 1 through 10
	double pressing the number will copy to clipboard
   
Alt + UpArrow and Downarrow to go up 1 message or down 1

Alt + PageUp and PageDown to go up 10 messages or down 10

Alt + U  - copies url in currently selected message, double tapping
         will open the url in the current message
			
Alt + Delete - will delete a category

Ctrl + Tab - This will switch you to the global notepad window
             which captures all output from the mud for you to review


Commands:

rev or review [any command]
           - This will put the output from any command you send into your Review category

vi add    - allows you to add lines/categories yourself
             vi add All=Text line to add

Settings:

vi int    - this toggles between using TTS interrupts and regular messages
             when reviewing, category changes will still be TTS messages

Custom categories:
You can easily add lines to existing categories, or make your own.

Simply make a trigger "Send To" Execute
	vi add All=Text line to add

This example would add the line "Text line to add" to the existing All
category. You could also create your own category.


]]>
</description>

</plugin>

<!--  Aliases  -->

<aliases>
  <alias
   script="gmcp_quest_info"
   match="^q(u(e(s(t?)?)?)?)? i(n(f(o?)?)?)?$"
   enabled="y"
   omit_from_command_history="n"
   omit_from_log="n"
   regexp="y"
   omit_from_output="n"
   sequence="100"
  >
  </alias>
  <alias
   script="review"
   match="^re(v(i(e(w?)?)?)?) (?<command>.+?)$"
   enabled="y"
   omit_from_command_history="n"
   omit_from_log="n"
   regexp="y"
   omit_from_output="n"
   sequence="100"
  >
  </alias>
  
  <alias
   script="review_delete"
   match="^review_delete"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>

  <alias
   script="review_category_move"
   match="^review_category_move (\w+)"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_url"
   match="^review_url$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_add"
   match="^vi add (\w+)=(.*)"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   keep_evaluating="n"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_add"
   match="^vi add.?"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   keep_evaluating="n"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="vi"
   match="^vi(.+)"
   enabled="y"
   keep_evaluating="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_get"
   match="^review_get (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   regexp="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   match="buffer_get_line *"
   enabled="y"
   script="buffer_get_line"
   omit_from_output="y"
   omit_from_log="y"
   omit_from_command_history="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  
  <alias
   script="review_catprev"
   match="review_catprev"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_catnext"
   match="review_catnext"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_msgprev"
   match="^review_msgprev (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_msgnext"
   match="^review_msgnext (\d+)$"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   script="review_msgcopy"
   match="review_msgcopy"
   enabled="y"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
</aliases>

  <triggers>
  <trigger
  enabled="y"
  group="Alert"
  match="^Global Quest:.+$"
  name="GqTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
	review_addline("Quests", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^\*(?!\*)(.*)$"
  name="GlobalEmoteTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
	review_addline("Say", "%0")
  </send>
  </trigger>

  <trigger
  enabled="y"
  group="Alert"
  match="^INFO:.+$"
  name="InfoTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^Restore:.+$"
  name="RestoreTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
  </send>
  </trigger>
  
  
  <trigger
  enabled="y"
  group="Alert"
  match="^You gain (.+) hit points, (.+) mana, (.+) moves, (.+) practices and (.+) trains\.$"
  name="GainLevelInfoTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
   review_addline("All", "%0")
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>

  <trigger
  enabled="y"
  group="Alert"
  match="^You receive (.+) experience points.$"
  name="Exp1Trigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^Lucky! You gain an extra (.+) training session(s?)!$"
  name="LuckyTrainsTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>

  <trigger
  enabled="y"
  group="Alert"
  match="^You have (.+) daily blessing bonus (.+) kills remaining\.$"
  name="DailyBlessingBonusKillsTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>
    
  <trigger
  enabled="y"
  group="Alert"
  match="^You gain (.+) extra trains daily blessing bonus\.$"
  name="DailyBlessingTrainsTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
   review_addline("All", "%0")
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>

  <trigger
  enabled="y"
  group="Alert"
  match="(\*?)(\*?)(\s?)You gain a bonus (.+)(\s?)(\*?)(\*?)$"
  name="GainBonusTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
   review_addline("All", "%0")
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^You receive (.+) experience points in honor of (.+) reaching superhero.$"
  name="Exp2Trigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("Kill Summary", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^Congratulations, hero. You have increased your powers!$"
  name="PupTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Kill Summary", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^You raise a level! You are now level (.+)\.$"
  name="LevelUpTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Kill Summary", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^You get ((?!gold coins).)* from (.+) corpse of (.+)\.$"
  name="LootTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
   review_addline("Kill Summary", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="Type 'group accept *' or 'group decline *' to accept or decline."
  name="GroupInviteTrigger"
  regexp="n"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "Group invite from %1. Group accept %1 or group decline %1.")
   review_addline("Group", "Group invite from %1. Group accept %1 or group decline %1.")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="You have joined the group: *"
  name="GroupJoinTrigger"
  regexp="n"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Group", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="* has kicked you from the group."
  name="GroupKickedTrigger"
  regexp="n"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Group", "%0")
  </send>
  </trigger>

  <trigger
  enabled="y"
  group="Alert"
  match="You start to follow *."
  name="StartFollowTrigger"
  regexp="n"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Group", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="You stop following *."
  name="StopFollowTrigger"
  regexp="n"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Group", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="You have removed yourself from group: *"
  name="GroupRemoveSelfTrigger"
  regexp="n"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("All", "%0")
   review_addline("Group", "%0")
  </send>
  </trigger>
  
  <trigger
  enabled="y"
  group="Alert"
  match="^(WARFARE|GENOCIDE):.+$"
  name="WarfareTrigger"
  regexp="y"
  send_to="12"
  sequence="100"
  >
  <send>
	review_addline("Warfare", "%0")
  </send>
  </trigger>
  	<trigger
		name="RequestCampaign"
		match="^(.+) tells you \'Good luck in your campaign\!\'$"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
	>
		<send>check_silent("cp")</send>
	</trigger>
   
      <trigger
		match="^You will no longer receive experience\. Happy questing\!$"
      name="trg_noexp_on"
		script="event_noexp_on"
      enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
      send_to="12"
		>
	</trigger>
   
   <trigger
		match="^You will now receive experience\. Happy leveling\!$"
      name="trg_noexp_off"
      script="event_noexp_off"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
      send_to="12"
		>
	</trigger>
</triggers>
<!--  Script  -->


<script>
<![CDATA[

require "gmcphelper"
dofile (GetInfo(60) .. "aardwolf_colors.lua")

local internal_ver = "1.0.8"
local gmcp_handler_id = "3e7dedbe37e44942dd46d264"
local modes = {} -- for keyboard states
local messages = {}
local indices = {}
local currentList = {}
local max_buffer_size = 838860
local initialized = false
currentList["cp"] = {}
currentList["gq"] = {}
local currentIndex = 1
local cpList = {}
local globalbuffer = {}
local notepadbuffer = {}
local silentCheck = true
local lastState
local current_category = 0 -- not set yet
local current_msg_id = 0
local on_global_quest = false
local listIndexing = true

local categories = {}

-- set up accelerators
for i = 1, 9 do
	Accelerator("alt + " .. i, "review_get " .. i) -- current category message buffers
	Accelerator("ctrl + " .. i, "buffer_get_line " .. i) -- These are global message buffers
end
Accelerator("alt + 0", "review_get 10") -- 10 is a special case
Accelerator("ctrl + 0", "buffer_get_line 10")
Accelerator("alt + right", "review_catnext")
Accelerator("alt + left", "review_catprev")
Accelerator("alt + down", "review_msgnext 1")
Accelerator("alt + up", "review_msgprev 1")
Accelerator("alt + pagedown", "review_msgnext 10")
Accelerator("alt + pageup", "review_msgprev 10")
Accelerator("alt + end", "review_msgnext 200")
Accelerator("alt + home", "review_msgprev 200")
Accelerator("shift+alt + right", "review_category_move right")
Accelerator("shift+alt + left", "review_category_move left")
Accelerator("alt+delete","review_delete")
Accelerator("alt + space", "review_msgprev 0")
Accelerator("alt+shift+space","review_msgcopy")
Accelerator("alt + u", "review_url")


function review_addline(catname, line)
	review_add(nil, nil, {catname, line})
end

function gmcp_quest_info(name, line, w)
	Execute("sendgmcp request quest") -- request gmcp quest info
	Send("quest info") -- send the server side command also
end

function scheck(name, line, wc)
   check_silent("cp")
end

function review(name, line, w)
	logmsg("review cmd used on: " .. w.command)
	SendNoEcho("echo {START_REVIEW}")
	Send(w.command) -- send the server side command also
	SendNoEcho("echo {END_REVIEW}")
end

function check_silent(type)
	if not listIndexing then return end
	EnableTrigger("event_" .. type .. "_list_start", true)
	silentCheck = true
	SendNoEcho("echo {START_" .. string.upper(type) .. "LIST}")
	SendNoEcho(type .. " check")
	SendNoEcho("echo {END_" .. string.upper(type) .. "LIST}")
	logmsg("silent check requested (" .. type .. ")")
end

function OnPluginGetFocus()
	if(#notepadbuffer>0) then
      if not initialized then return end
		for i, buffered in ipairs(notepadbuffer) do
         appendQueue(buffered)
		end
		notepadbuffer = {}
	end
end

local appendBuffer = ""
local lastAppend
function appendQueue(line)
	if GetNotepadLength("output") > max_buffer_size then
		local oldbuffer = GetNotepadText("output")
		ReplaceNotepad("output", string.sub(oldbuffer, max_buffer_size / 2))
	end
	
	appendBuffer = appendBuffer .. line .. "\r\n"
   
   if not initialized then return end
	
	if appendBuffer ~= nil and ((lastAppend == nil) or (lastAppend < os.time())) then
		AppendToNotepad("output", appendBuffer)
		appendBuffer = ""
		lastAppend = os.time()
	end
	if appendBuffer ~= "" then
		DoAfterSpecial(1, "emptyQueue()", 12)
	end
	
end

function emptyQueue()

	if GetNotepadLength("output") > max_buffer_size then
		local oldbuffer = GetNotepadText("output")
		ReplaceNotepad("output", string.sub(oldbuffer, max_buffer_size / 2))
	end
	if appendBuffer ~= "" then
		AppendToNotepad("output", appendBuffer)
		appendBuffer = ""
		lastAppend = os.time()
		return
	end
end

function OnPluginScreendraw(t,l,line)
	--real max_buffer_size = 1048575
	
	if line == nil or line == "" or t > 1 then
		return
	end
	table.insert(globalbuffer, 1, line)
	globalbuffer[11] = nil
   if(GetInfo(113) == false) then
      table.insert(notepadbuffer, line)
   else
      appendQueue(line)
   end
end

function buffer_get_line(name, line, wc)

	wc = tonumber(wc[1])
	line = globalbuffer[wc]
		
	local timeout = 0.4 -- in seconds
	if modes[wc] == nil then
		modes[wc] = {os.clock(), 1}
	elseif os.clock()-modes[wc][1] >= timeout then
		modes[wc][1] = os.clock()
		modes[wc][2] = 1
	else
		modes[wc][1] = os.clock()
		modes[wc][2] = modes[wc][2] + 1
	end
	if modes[wc][2] > 2 then
		modes[wc][2] = 2
	end
	if modes[wc][2] == 2 then
		SetClipboard(line)
		Execute(";tts_interrupt copied.")
	end
	if modes[wc][2] == 1 then
		Execute(";tts_interrupt "..line)
	end
end

function review_clear_cat(cat)
	if cat ~= nil and #cat ~= 0 then
		for i = 1, #categories do
			if cat == categories[i] then
				logmsg("Cleared category: " .. categories[i])
				messages[categories[i]] = nil
				indices[categories[i]] = nil
			end
		end
		return
	end
end

function message_select(msg_index)
	current_msg_id = tonumber(msg_index)
	local t = {
		catname = categories[current_category],
		msg = messages[categories[current_category]][msg_index],
		index = msg_index
		}
	logmsg("Message index " .. msg_index .. " selected. Category is \"" .. categories[current_category] .. "\".")
	BroadcastPlugin(101, serialize.save_simple(t)) -- broadcast we have selected a new message in a category
end

function review_delete(n,l,w)
	if #categories == 0 then
		speak("no categories")
		return
	end
	if current_category == 0 then
		speak("No category selected.")
		return
	end
	messages[categories[current_category]] = nil
	indices[categories[current_category]] = nil
	table.remove(categories, current_category)
	if current_category > #categories then
		current_category = 1
	end
	if #categories > 0 then
		speak(categories[current_category])
	else
		speak("no more categories.")
	end
end

function review_category_move(name, line, w)
	if #categories == 0 then
		speak("no categories")
		return
	end
	if current_category == 0 then
		speak("No category selected.")
		return
	end
	name = categories[current_category]
	table.remove(categories,current_category)
	if w[1]=="right" then
		current_category = current_category + 1
	if current_category > #categories + 1 then
		current_category = 2
	end
	else
		current_category = current_category - 1
		if current_category < 1 then
			current_category = #categories
		end
	end
	table.insert(categories, current_category, name)
	speak("moved.")
end

local function has_value(table, val)
	for i = 1, #table do
		if table[i] == val then
		    return true
	        end
	end
	return false
end

function review_add(name, line, wc)
	local cat, msg = wc[1], wc[2]

	if wc[1] == nil or wc[2] == nil then
		printmsg("Usage is\nvi add All=Text line to add")
		return
	end
	if messages[cat] == nil then
		if has_value(categories, cat) then
			-- Already have category, clearing messages and indices
			messages[cat] = {}
			indices[cat] = 0
		else
			messages[cat] = {}
			indices[cat] = 0
			table.insert(categories, cat)
		end
	end

	if msg ~= "" then
		table.insert(messages[cat], msg)
		local t = {cat, msg}
		BroadcastPlugin(100, serialize.save_simple(t)) -- broadcast we have a new message added to a buffer
		logmsg("addBuffer[" .. cat .. "] - " .. msg)
	end
	-- if we go over 100 items, remove the oldest one
	if #messages[cat] > 100 then
		table.remove(messages[cat], 1)
		if indices[cat] > 1 then
			indices[cat] = indices[cat] - 1
		end
	end
end


-- helper function to say stuff
function speak(msg, mode)

	if GetVariable("tts_interrupt") ~= "1" and mode ~= "tts" then
		mode = "note"
	else
		mode = "tts"
	end


	--if mode == nil then mode = "tts" end
	if mode == "tts" then
		Execute(";tts_interrupt " .. msg)
	else
		Note(msg)
	end
end

function review_url(name, line, wc)
	local timeout = 0.5 -- in seconds
	
	local item = current_msg_id
	
	if current_category == nil or current_msg_id == nil or messages[categories[current_category]] == nil then
		speak("no message selected")
		return
	end
	local msgstr = messages[categories[current_category]][current_msg_id]
	
	if msgstr == nil then
		speak("no message selected")
		return
	end 
	
	local url = url_from_string(messages[categories[current_category]][current_msg_id])
	if url == nil then
		speak("no url found")
		return
	end
	if modes[item] == nil then
		modes[item] = {os.clock(), 1}
	elseif os.clock()-modes[item][1] >= timeout then
		modes[item][1] = os.clock()
		modes[item][2] = 1
	else
		modes[item][1] = os.clock()
		modes[item][2] = modes[item][2] + 1
	end

	if modes[item][2] > 2 then
		modes[item][2] = 2
	end
	
	if modes[item][2] == 1 then
	
		SetClipboard(url)
		speak("copied url")
	elseif modes[item][2] == 2 then
		OpenBrowser(url)
		speak("opening url")
	end
	
end

function url_from_string(str)
	local pattern = "https?://[%w-_%.%?%.:/%+=&]+"
	local start, stop = (string.find(str, pattern))
	
	if start == nil then
		return
	end
	
	local url = string.sub(str, start, stop)
	url = string.gsub(url, "'", "") -- strip apostrophes out from some comm channels (these aren't used in urls in general)
	stop = url:find(' ')
	if stop ~= nil then 
		url = string.sub(url, 1, stop - 1)
	end
	return url
end

function review_get(name, line, wc)
	local str = ""
	if current_category == 0 and #categories == 0 then
		speak("No categories")
		return
	elseif current_category == 0 and #categories > 0 then
		for i, result in ipairs(categories) do
			if categories[i] == "All" then
				current_category = i
			end
		end
		if current_category > 0 then
			str = str .. "switching to all."
		else
			str = str .. "switching to " .. categories[1] .. ". Use alt left and right arrows to change."
			current_category = 1
		end
	end
	if messages[categories[current_category]] == nil then
		speak("No messages.")
		return
	end
	local item = tonumber(wc[1])
		if #messages[categories[current_category]] < item then
		speak("no message")
		return
	end

	-- now that all that's out of the way, we can start our real code which should always succeed.
	local timeout = 0.5 -- in seconds
	if modes[item] == nil then
	modes[item] = {os.clock(), 1}
	elseif os.clock()-modes[item][1] >= timeout then
	modes[item][1] = os.clock()
	modes[item][2] = 1
	else
	modes[item][1] = os.clock()
	modes[item][2] = modes[item][2] + 1
	end
	if modes[item][2] > 2 then
	modes[item][2] = 2
	end

	local real_item = #messages[categories[current_category]] + 1 - item
	if modes[item][2] == 1 then
		speak(str .. " " .. messages[categories[current_category]][real_item])
		elseif modes[item][2] == 2 then
		SetClipboard(messages[categories[current_category]][real_item])
		speak("copied")
	end
	
	message_select(real_item)
end

function review_catnext(name, line, wc)
	current_msg_id = 0;
	local mode = nil
	if #categories == 0 then
		speak("no categories", "tts")
		return
	end
	current_category = current_category + 1
	
	if current_category > #categories then
		current_category = 1
	end
	if ((messages[categories[current_category]] == nil) or (#messages[categories[current_category]] == 0)) and categories[current_category] ~= "All" then
		repeat
		logmsg("Skipping empty category: " .. categories[current_category])
		current_category = current_category + 1
		if current_category > #categories then
			current_category = 1
		end
		if messages[categories[current_category]] == nil then return end
		-- skip empty categories until one with messages is reached, or All category is encountered
		until categories[current_category] == "All" or (#messages[categories[current_category]] ~= 0)
	end
	speak(categories[current_category], "tts")
	if messages[categories[current_category]] ~= nil then
		message_select(#messages[categories[current_category]])
	end
end

function review_catprev(name, line, wc)
	current_msg_id = 0;
	local mode = nil
	if #categories == 0 then
		speak("no categories", "tts")
		return
	end
	current_category = current_category - 1
	
	if current_category < 1 then
		current_category = #categories
	end
	if ((messages[categories[current_category]] == nil) or (#messages[categories[current_category]] == 0)) and categories[current_category] ~= "All" then
		repeat
		logmsg("Skipping empty category: " .. categories[current_category])
		current_category = current_category - 1
		if current_category < 1 then
			current_category = #categories
		end
		if messages[categories[current_category]] == nil then return end
		-- skip empty categories until one with messages is reached, or All category is encountered
		until (#messages[categories[current_category]] ~= 0) or categories[current_category] == "All"
	end
	speak(categories[current_category], "tts")
	if messages[categories[current_category]] ~= nil then 
		message_select(#messages[categories[current_category]])
	end
end

function review_msgnext(name, line, wc)
	local skip = tonumber(wc[1])
	local str = ""
	if messages[categories[current_category]] == nil then return end
	if #messages[categories[current_category]] == 0 or indices[categories[current_category]] == nil then
		speak("No messages.")
		return
	end
	if #categories == 0 then
		speak("no categories")
		return
	end
	if current_category == 0 then
		speak("No category selected.")
		return
	end
	if indices[categories[current_category]] == 0 then
		indices[categories[current_category]] = #messages[categories[current_category]]
	end
	if indices[categories[current_category]] + skip > #messages[categories[current_category]] then
		indices[categories[current_category]] = #messages[categories[current_category]]
		str = str .. "Bottom: "
	else
		indices[categories[current_category]] = indices[categories[current_category]] + skip
	end
	
	local msg = messages[categories[current_category]][indices[categories[current_category]]]
	if msg ~= nil then
		speak(str .. msg)
	else
		speak("No messages.")
	end
	local real_item = indices[categories[current_category]]
	message_select(real_item)
end

function review_msgprev(name, line, wc)
	local skip = tonumber(wc[1])
	local str = ""
	if messages[categories[current_category]] == nil then return end
	if #messages[categories[current_category]] == 0 or indices[categories[current_category]] == nil then
		speak("No messages.")
		return
	end
	if #categories == 0 then
		speak("no categories")
		return
	end
	if current_category == 0 then
		speak("No category selected.")
		return
	end
	if indices[categories[current_category]] == 0 then
		indices[categories[current_category]] = #messages[categories[current_category]]
	end
	if indices[categories[current_category]] - skip < 1 then
		indices[categories[current_category]] = 1
		str = str .. "Top: "
	else
		indices[categories[current_category]] = indices[categories[current_category]] - skip
	end

	local msg = messages[categories[current_category]][indices[categories[current_category]]]
	if msg ~= nil then
		speak(str .. msg)
	else
		speak("No messages.")
	end
	local real_item = indices[categories[current_category]]
	message_select(real_item)
end

function review_msgcopy(name, line, wc)
	if #categories == 0 then
		speak("no categories")
		return
	end
	if current_category == 0 then
		speak("No category selected.")
		return
	end
	if indices[categories[current_category]] == 0 then
		indices[categories[current_category]] = #messages[categories[current_category]]
	end
	SetClipboard(messages[categories[current_category]][indices[categories[current_category]]])
	speak("copied")
end

function vi_help(AliasName, AliasLine, wildcards)
        print("")
        NoteStyle(2)
        print("Aardwolf VI Review Buffers Plugin v" .. internal_ver)
        NoteStyle(0)
        print("")
        ColourNote("SteelBlue", "", GetPluginInfo (GetPluginID (), 3))
        print("")
        return
end

function OnPluginInstall()
        print("")
        Note("Loaded Aardwolf VI Review Buffers plugin, type \"vi help\" for shortcuts and commands")
        print("")
	if GetVariable("tts_interrupt") == nil then
		SetVariable("tts_interupt", "1")
	end
end


function init()
   logmsg("Initializing output notepad..")
   if listIndexing then check_silent("cp") end
   AppendToNotepad("output", "Capturing all output\r\n")
   NotepadSaveMethod ("output", 2) -- this suppresses the save dialog when closing mush
   -- this seems to automove cursor to last line every time the notepad changes rendering it useless for vi review :(
   NotepadReadOnly ("output", true) -- Make it read only so we don't overwrite the text accidentally

end

function parse_list(list, mode)

	-- mode can be CP or QP
	
	local index = #list+1
	local place
	line_spacing = 0
	local offset = 34
	review_clear_cat(mode) -- clear the old buffer and fill with new data
	
	for i,v in ripairs (list) do
		index = index - 1
		local qty = ""
		if (v.qty > 1) then
			qty = string.format("%s * ", v.qty)
		end
		
		local mobText = v.mob
		local deadFlag = false
		if (v.isDead ~= nil and v.isDead ~= "") then
			mobText = mobText .. " [Dead]"
			deadFlag = true
		end
		if (v.type == "area") then
			place = string.format("%s", v.areaId)
		elseif (v.type == "room") then
			place = string.format("'%s' (%s) [%s-%s]", v.roomName, v.areaId, v.min, v.max)
		else -- unknown
			place = string.format("'%s' is Unknown", v.roomName, v.areaId)
		end
		local displayText = string.format("%s) %s%s - %s", index, qty, mobText, place)
		review_addline(mode, displayText)
		for i = 1, #categories do
			if categories[i] == mode then
				message_select(#messages[categories[i]])
			end
		end
		--Note(displayText)
	end
end

-- reverse ipairs function
function ripairs(t)
	local function ripairs_it(t,i)
		i=i-1
		local v=t[i]
		if v==nil then return v end
		return i,v
	end
	return ripairs_it, t, #t+1
end

function OnPluginBroadcast (msg, id, name, text)
	if (id == '3e7dedbe37e44942dd46d264') then              -- GMCP Handler plugin
		
		if (text == "comm.channel") then
			local channel = gmcp("comm.channel.chan")
			local msg = gmcp("comm.channel.msg")
			local t
			msg = strip_colours(msg)
			local url = url_from_string(msg)
			--print(url)
			review_addline("All", msg)
	
			if url ~= nil then --url in one of the comm messages, let's move this to URL window for history
				review_addline("URLs", msg)
			end
	
			if channel == "say" then
				t = {"Say", msg}
			elseif channel == "gtell" then
				t = {"Group", msg}
			elseif channel == "tell" then
				t = {"Tells", msg}
			elseif channel == "clantalk" then
				t = {"Clan", msg}
			elseif channel == "claninfo" then
				t = {"Clan", msg}
			elseif channel == "auction" then
				t = {"Commerce", msg}
			elseif channel == "market" then
				t = {"Commerce", msg}
			elseif channel == "barter" then
				t = {"Commerce", msg}
			elseif channel == "spouse" then
				t = {"Spouse", msg}
			elseif channel == "answer" then
				t = {"Answers", msg}
			elseif channel == "question" then
				t = {"Answers", msg}
			elseif channel == "gossip" then
				t = {"Gossip", msg}
			elseif channel == "helper" then
				t = {"Helper", msg}
			elseif channel == "ftalk" then
				t = {"Friend", msg}
			elseif channel == "newbie" then
				t = {"Newbie", msg}
			else
				return -- this *should* stop duplicates, if not we'll see
			end
	
			if t ~= nil then
				review_add(nil, nil, t)
			end
			return
      elseif (text == "comm.repop") then
         local area = gmcp("comm.repop.zone")
         review_addline("All", "Zone \"" .. area .. "\" has repopped.")
      elseif (text == "room.info") then
            if not initialized then
               initialized = true
               init()
            end
      elseif (text == "char.vitals") then
            if not initialized then
               initialized = true
               init()
            end
		elseif (text == "comm.quest") then
			local action = gmcp("comm.quest.action")
			local quest = gmcp("comm.quest")
			local msg
	
			if (action == "ready") then
				msg = "You may now quest again."
		
			elseif (action == "reset") then
				local timer = quest.timer
				msg = "Quest timer has been reset to " .. timer .. " minutes."
		
			elseif (action == "fail") then
				local wait = quest.wait
				msg = "Quest has failed! You can quest again in " .. wait .. " minutes."
		
			elseif (action == "warning") then
				local time = quest.time
				msg = "Quest warning: " .. time .. " minutes remaining!"
	
			elseif (action == "timeout") then
				local wait = quest.wait
				if wait == "0" then
					msg = "You have run out of time for quest. You may try again now."
				else
					msg = "You have run out of time for quest. You may take one again in " .. wait .. "minutes."
				end
		
			elseif (action == "killed") then
				msg = "Your quest is almost complete!"

			elseif (action == "comp") then
				local totqp = quest.totqp
				msg = "Quest completed for " .. totqp .. " QPs."
		
			elseif (action == "status") then
				local target = quest.targ
				local starget = quest.target
				local room = quest.room
				local area = quest.area
				local wait = quest.wait
				local timer = quest.timer 
				local status = quest.status
		
				if wait ~= nil then
					msg = "There are " .. wait .. " minutes remaining until you can go on another quest"
				elseif status == "ready" then
					msg = "You do not have to wait to go on another quest."
				elseif target == "missing" then
					msg = "Quest target is missing! Not in room or area!"
				elseif starget == "killed" then
					msg = "Your quest is almost complete!"
				else
					msg = "Quest target is \"" .. target .. "\" in room \"" .. room .. "\" of area: \"" .. area .. "\"" .. ", " .. timer .. " minutes remaining."
				end
		
			elseif (action == "start") then
				local target = quest.targ
				local room = quest.room
				local area = quest.area
				msg = "Quest target is \"" .. target .. "\" in room \"" .. room .. "\" of area: \"" .. area .. "\""
			end 
			if msg ~= nil then
				review_addline("All", msg)
				review_addline("Quests", msg)
			end
		end
	end
end

function parse_list_line(type, wc)
	currentList[type][currentIndex] = {
		mob = wc.mob,
		where = wc.where,
		isdead = wc.isdead,
		qty = tonumber(wc.qty)
		}
	currentIndex = currentIndex + 1
end

function event_gq_line(name, line, wc, styles)
	logmsg("parse_list_line: (gq) " .. line)
	parse_list_line("gq", wc)
end

function event_gq_reward_note(name, line, wc, styles)

end

function event_gq_remaining(name, line, wc, styles)

end

function category_select(index)
	current_category = index
	if messages[categories[current_category]] ~= nil then
		message_select(#messages[categories[current_category]])
	end
	return
end

function event_cp_line(name, line, wc, styles)
	logmsg("parse_list_line: (cp) " .. line)
	parse_list_line("cp", wc)
end

function event_gq_join(name, line, wc, styles)
	logmsg("event_gq_joinstart(): " .. line)
	EnableTrigger("event_gq_join", false)
	
	EnableTrigger("event_gq_end", true)
	EnableTrigger("event_gq_list_start", true)
	EnableTrigger("event_gq_line", true)
	EnableTrigger("event_gq_start", true) -- watch for start event
	check_silent("gq")
end

function event_gq_start(name, line, wc, styles)
	logmsg("event_gq_start() fired")
	EnableTrigger("event_gq_start", false)
	EnableTrigger("event_gq_end", true)
	EnableTrigger("event_gq_list_start", true)
	EnableTrigger("event_gq_line", true)
	check_silent("gq")
end

function event_cp_end(name, line, wc, styles)
	logmsg("event_cp_end() fired")
	EnableTrigger("event_cp_line", false)
	EnableTrigger("event_cp_end", false)
	EnableTrigger("event_cp_mob_kill", false)
	clear_list("cp")
end

function event_gq_end(name, line, wc, styles)
	logmsg("event_gq_end() fired")
	EnableTrigger("event_gq_end", false)
	clear_list("gq")
end

function clear_list(type)
	currentList[type] = {}
	review_clear_cat(string.upper(type))
end

function event_gq_list_start(name, line, wc, styles)
	local type = "gq"
	EnableTrigger("event_" .. type .. "_line", true) -- watch for lines
	EnableTrigger("event_" .. type .. "_end", true) --watch for end
	EnableTrigger("event_" .. type .. "_note", true) --watch for notes
	
	if (silentCheck) then
		SetTriggerOption("event_" .. type .. "_line", "omit_from_output", "1")
		SetTriggerOption("event_" .. type .. "_line", "omit_from_log", "1")
		SetTriggerOption("event_" .. type .. "_note", "omit_from_output", "1")
		SetTriggerOption("event_" .. type .. "_note", "omit_from_log", "1")
		SetTriggerOption("event_" .. type .. "_end", "omit_from_output", "1")
		SetTriggerOption("event_" .. type .. "_end", "omit_from_log", "1")
	end
	start_list("gq")
end

function event_cp_list_start(name, line, wc, styles)
	local type = "cp"
	EnableTrigger("event_" .. type .. "_line", true) -- watch for lines
	EnableTrigger("event_" .. type .. "_end", true) --watch for end
	EnableTrigger("event_" .. type .. "_note", true) --watch for notes
	
	if (silentCheck) then
		SetTriggerOption("event_" .. type .. "_line", "omit_from_output", "1")
		SetTriggerOption("event_" .. type .. "_line", "omit_from_log", "1")
		SetTriggerOption("event_" .. type .. "_note", "omit_from_output", "1")
		SetTriggerOption("event_" .. type .. "_note", "omit_from_log", "1")
		SetTriggerOption("event_" .. type .. "_end", "omit_from_output", "1")
		SetTriggerOption("event_" .. type .. "_end", "omit_from_log", "1")
	end
	start_list("cp")
end

function event_cp_list_end(name, line, wc, styles)
	end_list("cp")
end

function event_cp_time_left(name, line, wc, styles)
	
end

function event_cp_level_msg(name, line, wc, styles)
	
end

function event_review_start(name, line, wc, styles)
	EnableTrigger("event_review_capture", true) -- capture everything between tags
	EnableTrigger("event_review_end", true) -- watch for end tag
	logmsg("review_start fired")
end

function event_review_capture(name, line, wc, styles)
	review_addline("Review", strip_colours(line))
end

function event_review_end(name, line, wc, styles)
	logmsg("review_end fired")
	EnableTrigger("event_review_capture", false) -- stop capture
	EnableTrigger("event_review_end", false) -- don't watch for end tag
end

function event_cp_note(name, line, wc, styles)
	logmsg("event_cp_note fired!: " .. line)
end

function event_gq_note(name, line, wc, styles)
	logmsg("event_gq_note fired!: " .. line)
end

function start_list(type)
	EnableTrigger("event_" .. type .. "_line", true)
	EnableTrigger("event_" .. type .. "_mob_kill", true)
	EnableTrigger("event_" .. type .. "_list_end", true)
	EnableTrigger("event_" .. type .. "_note", true)
	EnableTrigger("event_" .. type .. "_end", true)
	currentList[type] = {}
	logmsg(type .. "_list_start() fired")
	review_clear_cat(string.upper(type))
end

function end_list(type)
	currentIndex = 1
	EnableTrigger("event_" .. type .. "_line", false)
	EnableTrigger("event_" .. type .. "_list_end", false)
	EnableTrigger("event_" .. type .. "_join", true)
	EnableTrigger("event_" .. type .. "_mob_kill", true)
	
	silentCheck = false
	SetTriggerOption("event_" .. type .. "_line", "omit_from_output", "0")
	SetTriggerOption("event_" .. type .. "_line", "omit_from_log", "0")
	SetTriggerOption("event_" .. type .. "_note", "omit_from_output", "0")
	SetTriggerOption("event_" .. type .. "_note", "omit_from_log", "0")
	SetTriggerOption("event_" .. type .. "_end", "omit_from_output", "0")
	SetTriggerOption("event_" .. type .. "_end", "omit_from_log", "0")
	
	logmsg(type .. "_list_end() fired .. list size: " .. #currentList[type])
	if #currentList[type] == 0 then
		logmsg("End of " .. type .. " list, list is empty.")
		return
	end	
	for index,value in ripairs(currentList[type]) do
		local strListItem = ""
		if value.qty ~= nil and value.qty > 1 then strListItem = value.qty .. " " end
		strListItem = strListItem .. value.mob .. "; in area: " .. value.where
			if (value.isdead ~= nil and value.isdead ~= "") then
				strListItem = strListItem .. "- Mob is dead!"
			end
		logmsg(string.upper(type) .. " buffer: " .. strListItem)
		review_addline(string.upper(type), strListItem)
		--set focus here
		
	end
	if type == "gq" then -- if it's a gquest we switch to gquest tab and proper entry
		logmsg("end_list type is gq, switching to category")
		current_category = find_catid_by_name(string.upper(type))
		if messages[categories[current_category]] ~= nil then
			if current_msg_id > #messages[categories[current_category]] or current_msg_id == 0 then
				message_select(#messages[categories[current_category]])
			end
		end
	end
end

function event_gq_list_end(name, line, wc, styles)
	end_list("gq")
end

function find_catid_by_name(cat)
	for i = 1, #categories do
		if categories[i] == cat then
			return i
		end
	end
return
end

function event_gq_mob_kill(name, line, wc, styles)
	logmsg("event_gq_mob_kill: " .. line)
	if listIndexing then check_silent("gq") return end
end

function event_cp_mob_kill(name, line, wc, styles)
	logmsg("event_cp_mob_kill: " .. line)
	if listIndexing then check_silent("cp") return end
end

function get_current_selection()
	local currCat = categories[current_category]
	local listLen
	if currentList[string.lower(currCat)] ~= nil then
		listLen = #currentList[string.lower(currCat)]
	end
	return currCat, current_msg_id, listLen
	
end

   function event_noexp_on(name, line, wc)
      review_addline("All", line)
   end
   
   function event_noexp_off(name, line, wc)
      review_addline("All", line)
   end

function create_triggers()

	local triggerFlags = trigger_flag.RegularExpression
	
	check (AddTriggerEx("event_gq_line",
	   "^You still have to kill (?<qty>[0-9]) \\* (?<mob>[^\\(]+) \\((?<where>.+?)(?<isdead> - Dead)?\\)$",
	   "",
	   triggerFlags,
	   -1, 0, "",
	   "event_gq_line", sendto.script, 1))	   

	check (AddTriggerEx("event_cp_line",
	   "^You still have to kill \\* (?<mob>[^\\(]+) \\((?<where>.+?)(?<isdead> - Dead)?\\)\\.?$",
	   "",
	   triggerFlags,
	   -1, 0, "",
	   "event_cp_line", sendto.script, 1))
	   	   
	check (AddTriggerEx("event_gq_join",
	   "^You have now joined Global Quest (.+) See 'help gquest' for available commands.$",
	   "",
	   triggerFlags + trigger_flag.Enabled,
	   -1, 0, "",
	   "event_gq_join", sendto.script, 1))

	check (AddTriggerEx("event_gq_start",
	   "^Global Quest: Global quest (.+) has now started\\.$",
	   "",
	   triggerFlags,
	   -1, 0, "",
	   "event_gq_start", sendto.script, 1))
	   
	check (AddTriggerEx("event_gq_mob_kill",
	   "^Congratulations, that was one of the GLOBAL QUEST mobs!$",
	   "",
	   triggerFlags,
	   -1, 0, "",
	   "event_gq_mob_kill", sendto.script, 1))
	
	check (AddTriggerEx("event_cp_mob_kill",
	   "^Congratulations, that was one of your CAMPAIGN mobs!$",
	   "",
	   triggerFlags + trigger_flag.Enabled,
	   -1, 0, "",
	   "event_cp_mob_kill", sendto.script, 1))   
	   
	check (AddTriggerEx("event_gq_end",
	   "^You are not in a global quest.$",
	   "",
	   triggerFlags,
	   -1, 0, "",
	   "event_gq_end", sendto.script, 1))
	   
	check (AddTriggerEx("event_cp_end",
	   "^(" ..
	   "^CONGRATULATIONS! You have completed your campaign.*|" ..
	   "You are not currently on a campaign.*" ..
	   ")$",
	   "",
	   triggerFlags,
	   -1, 0, "",
	   "event_cp_end", sendto.script, 1))
	   
	check (AddTriggerEx("event_review_start",
	   "^\\{START_REVIEW\\}$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput + trigger_flag.Enabled,
	   -1, 0, "",
	   "event_review_start", sendto.script, 0))
	
	check (AddTriggerEx("event_review_capture",
	   "^.*$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput + trigger_flag.KeepEvaluating,
	   -1, 0, "",
	   "event_review_capture", sendto.script, 1))
	   
	check (AddTriggerEx("event_review_end",
	   "^\\{END_REVIEW\\}$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput + trigger_flag.Enabled,
	   -1, 0, "",
	   "event_review_end", sendto.script, 0))
	   
	check (AddTriggerEx("event_gq_list_start",
	   "^\\{START_GQLIST\\}$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput + trigger_flag.Enabled,
	   -1, 0, "",
	   "event_gq_list_start", sendto.script, 1))
	   
	check (AddTriggerEx("event_gq_list_end",
	   "^\\{END_GQLIST\\}$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput,
	   -1, 0, "",
	   "event_gq_list_end", sendto.script, 1))
	   
	check (AddTriggerEx("event_cp_list_start",
	   "^\\{START_CPLIST\\}$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput + trigger_flag.Enabled,
	   -1, 0, "",
	   "event_cp_list_start", sendto.script, 1))
	   
	check (AddTriggerEx("event_cp_list_end",
	   "^\\{END_CPLIST\\}$",
	   "",
	   triggerFlags + trigger_flag.OmitFromLog + trigger_flag.OmitFromOutput,
	   -1, 0, "",
	   "event_cp_list_end", sendto.script, 1))
	
      check (AddTriggerEx("event_gq_note",
         "^(" ..
         "You can be rewarded for (.+) more kills this level.*|"       ..
         "Note\\: One or more target names in this gquest might be slightly scrambled.*|"    ..
         "You may win (.+) more gquests at this level.*" ..
	      ")$",
	      "",
	      triggerFlags,
	      -1, 0, "",
	      "event_gq_note", sendto.script, 1))
	    
   check (AddTriggerEx("event_cp_note",
      "^(" ..
      "You have (.+) left to finish this campaign\\.*|"       ..
      "You will have to level before you can go on another campaign\\.*|"       ..
      "You have completed (.+) campaigns today\\.*|"	..
      "You may take a campaign at this level.*|"       ..
      "Note\\: One or more target names in this campaign might be slightly scrambled.*|"    ..
      "Note\\: Dead means that the target is dead, not that you have killed it\\.*" ..
      ")$",
	      "",
      triggerFlags,
      -1, 0, "",
      "event_cp_note", sendto.script, 1))
end

create_triggers()

function printmsg(msg)
	ColourNote("steelblue", "", msg)
end

function logmsg(msg)
	if GetVariable("debug") == "1" then
		ColourNote("olive", "", "[dbg] ", "SteelBlue", "", msg)
	end
end

function vi(alias, line, wc)
	local togName
	if string.lower(wc[1]) == " debug" then
		togName = "debug"
	elseif string.lower(wc[1]) == " int" then
		togName = "tts_interrupt"
	elseif string.lower(wc[1]) == " help" then
		vi_help()
		return
	else
		ColourNote("steelblue", "", "Valid options are:")
		ColourNote("steelblue", "", "vi int                    > enables/disables tts interrupt for message review (not categories)")
		ColourNote("steelblue", "", "vi add Category=Message   > adds a line to and creates category")
		ColourNote("steelblue", "", "vi help                   > display help file")
		ColourNote("steelblue", "", "vi debug                  > enables/disables debug for testing only")
		return
	end
	if (GetVariable(togName) == "1") then
		SetVariable(togName, "0")
		print("")
		printmsg("vi review buffers: " .. togName .. " has been disabled.")
		print("")
	else
		SetVariable(togName, "1")
		print("")
		printmsg("vi review buffers: " .. togName .. " has been enabled.")
		print("")
	end
end
	
--set up initial important categories
review_add(nil, nil, {"All", ""})
current_category = 1
review_add(nil, nil, {"Say", ""})
review_add(nil, nil, {"Tells", ""})
review_add(nil, nil, {"Group", ""})
review_add(nil, nil, {"Clan", ""})
review_add(nil, nil, {"Answers", ""})
review_add(nil, nil, {"Commerce", ""})
review_add(nil, nil, {"URLs", ""})
review_add(nil, nil, {"Kill Summary", ""})
review_add(nil, nil, {"Quests", ""})
]]>
</script>
</muclient>