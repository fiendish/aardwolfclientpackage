<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
	name="Text_Substitutions"
	author="Fiendish"
	id="26240e292291e159e1ff3cde"
	language="Lua"
	purpose="Replace text with other text"
	date_written="2011-07-27 01:00:00"
	requires="4.75"
	version="1.0"
	save_state="y"
	sequence="-10000"
>

<description trim="y">
This plugin substitutes text with something else.

It does not cross color code boundaries.
'#sub {potato} {pants}' will make @Mpotato@Cpants@Rairplane@w become @Mpants@Cpants@Rairplane@w
but will not do anything to @Mpot@Yato@Cpants@Rairplane@w because, in this one, the word
potato has a color break inside it.

Type "#sub help" or make a syntax mistake for usage details.
</description>
</plugin>
<aliases>

<alias
	match="^#subs? *$"
	enabled="y"
	regexp="y"
	sequence="100"
	ignore_case="y"
	script="listsub"
></alias>

<alias
	match="^#sub +\{(.*)\} *\{(.*)\}( *(#nocase)| *(#alone)| *(#function))* *$"
	regexp="y"
	enabled="y"
	sequence="100"
	ignore_case="y"
	script="addsub"
></alias>

<alias
	match="^#sub ([\S]+).*$"
	enabled="y"
	regexp="y"
	sequence="200"
	ignore_case="y"
	script="helpsub"
></alias>

<alias
	match="^#unsub +#(\d+)$"
	regexp="y"
	enabled="y"
	sequence="100"
	ignore_case="y"
	script="remsub"
></alias>

<alias
	match="^#unsub.*$"
	enabled="y"
	regexp="y"
	sequence="101"
	ignore_case="y"
	script="helpsub"
></alias>

<alias
	match="^#gags? *$"
	enabled="y"
	regexp="y"
	sequence="100"
	ignore_case="y"
	script="listgag"
></alias>

<alias
	match="^#gag +\{(.*?)\}( *(#nocase)| *(#alone)| *\{(.*?)\})* *$"
	regexp="y"
	enabled="y"
	sequence="100"
	ignore_case="y"
	script="addgag"
></alias>

<alias
	match="^#gag ([\S]+).*$"
	enabled="y"
	regexp="y"
	sequence="200"
	ignore_case="y"
	script="helpsub"
></alias>

<alias
	match="^#ungag +#(\d+)$"
	regexp="y"
	enabled="y"
	sequence="100"
	ignore_case="y"
	script="remgag"
></alias>

<alias
	match="^#ungag.*$"
	enabled="y"
	regexp="y"
	sequence="101"
	ignore_case="y"
	script="helpsub"
></alias>

</aliases>

<triggers>
  <trigger
   name="all"
   enabled="y"
   match="^(.*)$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
   send_to="12"
   script="filter_trigger"
  ><send>
     if not GetInfo(123) then
        StopEvaluatingTriggers(true)
     end
   </send>
  </trigger>
</triggers>

<script>
<![CDATA[
-- fix stupid syntax highlighting in SublimeText --> '

require "serialize"
dofile(GetInfo(60) .. "aardwolf_colors.lua")

 -- init tables
loadstring( GetVariable("subs") or "subs = {}" )()
loadstring( GetVariable("gags") or "gags = {}" )()

function usagesub(line, embedded)
	if not embedded then
		Note()
	end

	if not embedded then
   	AnsiNote(ColoursToANSI("You typed: '@W"..line.."@Y'"))
		tts_warning()
		Note()
	end
	AnsiNote(ColoursToANSI("@YAvailable commands for the #sub/#gag plugin are:"..
	"\n@Y #subs             : List all current substitutions"..
	"\n@Y #gags             : List all current gags"..
	"\n@Y #sub {A} {B}      : Replaces phrase A with phrase B"..
	"\n@Y #unsub #<number>  : Removes numbered substitution"..
	"\n@Y #gag {A}          : Gag lines with phrase A"..
	"\n@Y #ungag #<number>  : Removes numbered gag"))
	if not embedded then
		AnsiNote(ColoursToANSI("@Y #sub help         : More complete help for this plugin"))
	end
	AnsiNote(ColoursToANSI("\n@G Note that you must use curly braces around each phrase for demarcation,"..
	"\n@G not quotation marks or anything else."..
	"\n@G Add @C#alone@G to the line to only match at word or color boundaries."..
	"\n@G Add @C#nocase@G to the line to do case-insensitive matching."))
	if not embedded then
		Note()
	end
end

function tts_warning()
	AnsiNote(ColoursToANSI("@cNote: If you are using text to speech, you will need to have enabled"..
	"\n@call punctuation reading to follow the documentation for this plugin."..
	"\n@cThe plugin uses some symbols for interaction, and the full help includes"..
	"\n@cexample Lua plugin code as well."))
end

function helpsub(name, line, wildcards)

	if wildcards[1] ~= "help" and wildcards[1] ~= "#help" then
		usagesub(line, false)
		return
	end

	local header = "begin help for the #sub/#gag plugin"
	AnsiNote(ColoursToANSI("\n\n@Y"..string.rep(" ", (60-#header)/2)..header))
	tts_warning()
	AnsiNote(ColoursToANSI("\n@w"..GetPluginInfo(GetPluginID(), 3):gsub("(@%w)", "%1@%1").."\n@Y"))
	usagesub(line, true)
	AnsiNote(ColoursToANSI(
	"@G example: @C#sub {hello} {Howdy} #alone #nocase"..
	"\n@G          This will match HeLlO but not othello."..
	"\n@G"..
	"\n@G You can use Lua gsub capture patterns too."..
	"\n@G example: @C#sub {(player)} {%1 (rude)} #alone #nocase"..
	"\n@G          This will do almost the same things as"..
	"\n@G          @C#sub {player} {player (rude)} #alone #nocase"..
	"\n@G          but it will preserve the original capitalization."..
	"\n@G          For more on these patterns read https://www.lua.org/pil/20.2.html"..
	"\n@G"..
	"\n@G Add @C#function@G to a #sub line to pass matching components to a plugin function"..
	"\n@G instead of doing a direct replacement."..
	"\n@G For this, your replacement pattern must be @Wplugin_id:function_name@G."..
	"\n@G example: @C#sub {player} {12345678901234567890abcd:my_example} #alone #function"..
	"\n@G          Then in your plugin with ID 12345678901234567890abcd,"..
	"\n@G          you would add a new my_example function. It could"..
	"\n@G          be something like:"..
	"\n@G@C        function my_example(...)"..
	"\n@G@C          local args = {...}"..
	"\n@G@C          if my_plugin_variable == 100 then"..
	"\n@G@C            -- returning a string says replace with this"..
	"\n@G@C            return args[1]..\" (@@Rbutternut squash$C)\""..
	"\n@G@C          else"..
	"\n@G@C            -- returning false or nil says don't do a replacement"..
	"\n@G@C            return false"..
	"\n@G@C          end"..
	"\n@G@C        end"..
	"\n@G Since gags don't normally have a replacement pattern field, adding one"..
	"\n@G will make them behave similarly."..
	"\n@G There is no need to add #function for gags."..
	"\n@G example: @C#gag {player} {12345678901234567890abcd:my_new_gag} #alone"..
	"\n@G          Then in your plugin with ID 12345678901234567890abcd,"..
	"\n@G          you could add a new my_new_gag function like:"..
	"\n@G@C        function my_new_gag()"..
	"\n@G@C          local line = CallPlugin(\"26240e292291e159e1ff3cde\",\"current_line\")"..
	"\n@G@C          if line:sub(1,15) == string.char(255,250,201)..\"comm.channel\" then"..
	"\n@G@C            -- returning true says gag this if it's a gmcp comm.channel message"..
	"\n@G@C            return true"..
	"\n@G@C          else"..
	"\n@G@C            -- returning false or nil says don't gag"..
	"\n@G@C            return false"..
	"\n@G@C          end"..
	"\n@G@C        end"..
	"\n@G@C"..
	"\n@G As shown, using @CCallPlugin(\"26240e292291e159e1ff3cde\", \"current_line\")@G"..
	"\n@G in your handler function will return the message being processed."..
	"\n@Y"..string.rep(" ", (60-#header:gsub("begin","end"))/2)..header:gsub("begin","end")))
end


function listsub(name, line, wildcards)
	ColourNote("yellow","","")
	ColourNote("yellow",""," Current #subs:")
	ColourNote("yellow","","/-----------------------------------------------------------------------------\\")
	for i,v in ipairs(subs) do
		AnsiNote(ColoursToANSI("@Y"..string.format("   %4u",i)..": "..format_sub(v)))
	end
	ColourNote("yellow","","\\-----------------------------------------------------------------------------/")
	ColourNote("yellow","","")
 end


function listgag(name, line, wildcards)
	ColourNote("yellow","","")
	ColourNote("yellow",""," Current #gags:")
	ColourNote("yellow","","/-----------------------------------------------------------------------------\\")
	for i,v in ipairs(gags) do
		AnsiNote(ColoursToANSI("@Y"..string.format("   %4u",i)..": "..format_gag(v)))
	end
	ColourNote("yellow","","\\-----------------------------------------------------------------------------/")
	ColourNote("yellow","","")
 end


function find_in(set, original, nocase, alone, use_function)
	for i,v in ipairs(set) do
		if v.original == original and v.nocase == nocase and v.alone == alone and v.use_function == use_function then
			return i
		end
	end
end


function remsub(name, line, wildcards, silent)
	local found_index = tonumber(wildcards[1])
	local found = found_index and subs[found_index] or false

	if not silent then
		Note()
		if found then
			AnsiNote(ColoursToANSI("@Ysub #"..found_index.." removed. Formerly: ["..format_sub(found).."]"))
		else
			ColourNote("yellow","","sub #"..tostring(wildcards[1]).." not found.")
		end
	end
	if found then
		table.remove(subs,found_index)
		OnPluginSaveState()
	end
end


function format_gag(gag)
	return "\"@W"..gag.original:gsub("@","@@").."@Y\""..(gag.nocase and " #nocase" or "")..(gag.alone and " #alone" or "")..
				(gag.use_function and (" @Y--> #function \"@W"..gag.use_function:gsub("@","@@").."@Y\"") or "")
end


function format_sub(sub)
	return "\"@W"..sub.original:gsub("@","@@").."@Y\""..(sub.nocase and " #nocase" or "")..(sub.alone and " #alone" or "")..
				" @Y--> "..
				(sub.use_function and "#function " or "").."\"@W"..sub.tostr:gsub("@","@@").."@Y\""
end


function remgag(name, line, wildcards, silent) 
	local found_index = tonumber(wildcards[1])
	local found = found_index and gags[found_index] or false
	
	if not silent then
		Note()
		if found then
			AnsiNote(ColoursToANSI("@Ygag #"..found_index.." removed. Formerly: ["..format_gag(found).."]"))
		else
			ColourNote("yellow","","gag #"..tostring(wildcards[1]).." not found.")
		end
	end
	if found then
		table.remove(gags,found_index)
		OnPluginSaveState()
	end
end


function addsub(name, line, wildcards)
	local fromstr = wildcards[1]
	local tostr = wildcards[2]
	local nocase = wildcards[4] ~= ""
	local alone = wildcards[5] ~= ""
	local use_function = wildcards[6] ~= ""

	if use_function then
		local s,e = tostr:find("%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x:%S*")
		if s ~= 1 or e ~= #tostr then
			AnsiNote(ColoursToANSI("\n@YYou specified @W#function@Y, but pattern '@W"..tostr.."@Y' does not meet the format requirements."..
				"\nPlease use {@W24_hexadecimal_digit_plugin_id:plugin_function_name@Y} as indicated in @W#sub help@Y."))
			return
		end
	end

	if nocase then
		fromstr = string.gsub(fromstr, '(%a)', function (v) return '['..string.upper(v)..string.lower(v)..']' end)
	end
	if alone then
		fromstr = "%f[^%c%z%s%p]"..fromstr.."%f[%c%z%s%p]"
	end
	if nocase or alone then
		ColourNote("yellow", "", "You specified"..(nocase and " #nocase" or "")..(alone and " #alone" or "")..", so converting your #sub patterns...")
		ColourNote("yellow", "", "")
		ColourNote("yellow", "", "\""..wildcards[1].."\"")
		ColourNote("yellow", "", "becomes")
		ColourNote("yellow", "", "\""..fromstr.."\"")
	end

	local found = find_in(subs, wildcards[1], nocase, alone, use_function)
	if found then remsub(nil, nil, {found}) end

	table.insert(subs, 
	{
		fromstr=fromstr, 
		tostr=tostr,
		original=wildcards[1],
		nocase=nocase,
		alone=alone,
		use_function=use_function
	})

	AnsiNote(ColoursToANSI("@YCreated sub "..#subs..": "..format_sub(subs[#subs])))
	OnPluginSaveState()
end


function addgag(name, line, wildcards)

	local gagstr = wildcards[1]
	local nocase = wildcards[3] ~= ""
	local alone = wildcards[4] ~= ""

	local use_function = wildcards[5] ~= "" and wildcards[5] or nil

	if use_function then
		local s,e = use_function:find("%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x:%S*")
		if s ~= 1 or e ~= #use_function then
			AnsiNote(ColoursToANSI("\n@YYou specified @W#function@Y, but pattern '@W"..use_function.."@Y' does not meet the format requirements."..
				"\nPlease use {@W24_hexadecimal_digit_plugin_id:plugin_function_name@Y} as indicated in @W#sub help@Y."))
			return
		end
	end

	if nocase then
		gagstr = string.gsub(gagstr, '(%a)', function (v) return '['..string.upper(v)..string.lower(v)..']' end)
	end
	if alone then
		gagstr = "%f[^%c%z%s%p]"..gagstr.."%f[%c%z%s%p]"
	end
	
	if alone or nocase then
		ColourNote("yellow", "", "You specified"..(nocase and " #nocase" or "")..(alone and " #alone" or "")..", so converting your #gag pattern...")
		ColourNote("yellow", "", "")
		ColourNote("yellow", "", "\""..wildcards[1].."\"")
		ColourNote("yellow", "", "becomes")
		ColourNote("yellow", "", "\""..gagstr.."\"")
	end

	local found = find_in(gags, wildcards[1], nocase, alone, use_function)
	if found then remgag(nil, nil, {found}) end

	table.insert(gags, {
		gagstr=gagstr, 
		original=wildcards[1],
		nocase=nocase,
		alone=alone,
		use_function=use_function
		})

	AnsiNote(ColoursToANSI("@YCreated gag "..#gags..": "..format_gag(gags[#gags])))
	OnPluginSaveState()
end


function OnPluginSaveState()
	SetVariable("subs", serialize.save("subs"))
	SetVariable("gags", serialize.save("gags"))
end


-- This string.split works like MUSHclient's utils.split, but allows 
-- any pattern and also allows you to preserve the pattern match entities.
function string.split(self, pat, add_pattern_matches_to_result)
	local fields = {}
	local start = 1
	self:gsub("()("..pat..")", 
		function(index,match)
			table.insert(fields, self:sub(start,index-1))
			if add_pattern_matches_to_result then
				table.insert(fields, match)
			end
			start = index + #match
		end
	)
	table.insert(fields, self:sub(start))
	return fields
end


prev_text = ""
EOL = "\n"

function OnPluginDisconnect()
	OnPluginConnect()
end


function OnPluginConnect()
	dosubs = false
	prev_text = ""
end


-- proxy_sub("26240e292291e159e1ff3cde:test")
function proxy_sub(plugin_func_str, prev_color)
	local callstart = 'local a,b = CallPlugin("'..plugin_func_str:gsub(':', '","')..'"'
	return function(...)
		local params = {}
		for n=1,select('#',...) do
			params[#params+1] = '"'..select(n,...):gsub('"', '\\"')..'"'
		end
		local func = callstart..(#params > 0 and (","..table.concat(params,",")) or "")..'); if a ~= 0 then Note("Error in sub: "..b) else return string.gsub(b,"%$C", "'..prev_color..'") end'
		return loadstring(func)()
	end
end


function proxy_gag(plugin_func_str)
	local callstart = 'local a,b = CallPlugin("'..plugin_func_str:gsub(':', '","')..'"'
	return function(...)
		local params = {}
		for n=1,select('#',...) do
			params[#params+1] = '"'..select(n,...):gsub('"', '\\"')..'"'
		end
		local func = callstart..(#params > 0 and (","..table.concat(params,",")) or "")..'); if a ~= 0 then Note("Error in gag: "..b) else return b end'
		return loadstring(func)()
	end
end


function do_gags_against_coded_colors_table(msg_t)
	for i = 1,#msg_t,2 do
		local color_bit = msg_t[i]
		for _,v in ipairs(gags) do
			if color_bit:find(v.gagstr) then
				if not v.use_function then
					return true
				else
					return proxy_gag(v.use_function)()
				end
			end
		end
	end
	return false
end


function do_subs_against_coded_colors_table(msg_t)
	for i = 1,#msg_t,2 do
		local color_bit = msg_t[i]
		for _,v in ipairs(subs) do
			local prev_color = msg_t[i-1] or "@x007"
			local replacement = v.use_function and proxy_sub(v.tostr, prev_color) or v.tostr:gsub("%$C", prev_color)
			local ok,ret = pcall(string.gsub, color_bit, v.fromstr, replacement)
			if not ok then 
				AnsiNote(ColoursToANSI("@YError in sub ["..format_sub(v).."]: "..ret))
			else 
				color_bit = ret
			end
		end
		msg_t[i] = color_bit
	end
	return table.concat(msg_t)
end


cur_line = ""
function current_line()
	return cur_line
end


function filter_trigger(name, line, wildcards, styles)
   if not GetInfo(123) then
      local new_line = filter_string(StylesToColoursOneLine(styles))
      if new_line then
         SetTriggerOption("all", "omit_from_output", "n")
         Simulate(ColoursToANSI(new_line)..ANSI(0).."\r\n")
         SetTriggerOption("all", "omit_from_output", "y")
      end
   end
end


-- returns nil if gagged, otherwise returns the modified message
-- input: string with Aardwolf color codes
function filter_string(msg)
	cur_line = msg
   
	-- Matching #alone patterns at color and line boundaries is easier if
	-- we can assume that color patterns are uniform. Make it so.
	local msg_t = canonicalize_colours(msg):split("%f[@]@x%d%d%d", true)

	local gagged = do_gags_against_coded_colors_table(msg_t)
	if not gagged then
		return do_subs_against_coded_colors_table(msg_t)
	else
		return nil
	end
end

]]>
</script>
</muclient>
