<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>

<plugin
   name="Aardwolf_Helpfile_Window"
   author="Fiendish"
   id="a1965272c8ca966b76f36fa3"
   language="Lua"
   purpose="Capture Aardwolf in-game help to a miniwindow"
   date_written="2020-12-05 16:33:00"
   requires="5.07"
   version="1.0"
   save_state="y"
   sequence="-9999"
>
</plugin>

<aliases>
<alias
   match="^(h|he|hel|help) +search +(.+)$"
   enabled="y"
   regexp="y"
   sequence="99"
   ignore_case="y"
   send_to="12"
><send>
Capture.command("%0", "^{helpsearch}$", "^{/helpsearch}$", true, false, true, false, process_search)
</send>
</alias>

<alias
   match="^(h|he|hel|help)( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
   send_to="12"
><send>
not_found_msg = "Help '"..Trim(string.lower("%2")).."' was not found - possible alternatives are:"
Capture.command("%0", "^{help}$", "^{/help}$", true, false, true, false, process_help)
</send>
</alias>
</aliases>

<script>
<![CDATA[
require "themed_miniwindows"
require "wrapped_captures"
require "gmcphelper"
dofile(GetInfo(60).."telnet_options.lua")


WINDOW_ID = GetPluginID()

string.starts_with = function(self, start)
   return self:sub(1, #start) == start
end

function OnPluginListChanged()
   dofile "lua/aard_requirements.lua"
end

function remove_trailing_whitespace(line)
   return ColoursToStyles(Trim(StylesToColours(line)))
end

function sanitize_search(style_lines)
   local new_lines = {}
   for i,line in ipairs(style_lines) do
      -- help search starts with a blank line that I want to remove
      if i ~= 1 then
          -- search lines have a bunch of trailing whitespace that makes wrapping worse
         new_lines[i-1] = remove_trailing_whitespace(line)
      end
   end
   return new_lines
end

function sanitize_help(style_lines)
   local new_lines = {}
   for _,line in ipairs(style_lines) do
      if (line[1].text ~= "{helpbody}") and (line[1].text ~= "{/helpbody}") then
         if line[1].text == "{helpkeywords}" then
            line[1].text = ""
            line[1].length = 0
         end
         table.insert(new_lines, remove_trailing_whitespace(line))
      end
   end
   return new_lines
end

string.find_indices = function(self, pattern, after, before)
   indices = {}
   local first, last = 0, 0
   before = before or #self+1
   while true do
      first, last = self:find(pattern, last+1)
      if not first then break end
      if (first > after) and (last < before) then
         table.insert(indices, {text=self:sub(first, last), start=first, stop=last})
      end
   end
   return indices
end

function build_links(line, pattern, after, before, verb)
   links = strip_colours_from_styles(line):find_indices(pattern, after, before)
   for _,v in ipairs(indices) do
      v.label = verb.." "..v.text
      v.text = 'not_found_msg = "Help \'"..Trim(string.lower("'..v.text..'")).."\' was not found - possible alternatives are:";Capture.command("'..verb.." "..v.text..'", "^{help}$", "^{/help}$", true, false, true, false, process_help)'
   end
   return links
end

function get_related_help_hyperlinks(style_lines)
   related_helps = {}
   related_categories = {}
   for i,line in ipairs(style_lines) do
      if line[1].text:starts_with("Related Helps") then
         related_helps[i] = build_links(line, "[%w-]+[%w- ]*", #"Related Helps : ", nil, "help")
      -- elseif line[1].text:starts_with("Help Category") then
      --    related_categories[i] = build_links(line, "[%w-]+[%w- ]*", #"Help Category", nil, "contents")
      end
   end
   return related_helps, related_categories
end

function get_search_hyperlinks(style_lines)
   related_helps = {}
   for i,line in ipairs(style_lines) do
      if (line[1].length == 20) and (line[2].text:sub(1,1) == ":") then
         related_helps[i] = build_links(line, "[%w-]+[%w- ]*", 0, 21, "help")
      end
   end
   return related_helps, {}
end

function divert_to_search_result_handler(window_styles)
   -- Should the game have used helpsearch tags instead of help tags?
   if GetLineInfo(GetLinesInBufferCount() - 1, 1) == not_found_msg then
      DeleteLines(1)
      new_window_styles = {
         ColoursToStyles(""),
         ColoursToStyles("@W"..not_found_msg),
         ColoursToStyles("")
      }
      for i,v in ipairs(window_styles) do
         new_window_styles[i+3] = v
      end
      process_search(new_window_styles)
      return true
   end
end

function no_help(window_styles)
   -- Is this just saying there's no help?
   if window_styles[1][1].text == "There is no help with that keyword." then
      for _,v in ipairs(window_styles) do
         Simulate(stylesToANSI(v).."\r\n")
      end
      return true
   end
end

function process_help(window_styles)
   if (window_styles == nil) or divert_to_search_result_handler(window_styles) or no_help(window_styles) then
      return
   end
   local window_styles = sanitize_help(window_styles)
   build_window(window_styles, get_related_help_hyperlinks)
end

function process_search(window_styles)
   if window_styles == nil then
      return
   end
   local window_styles = sanitize_search(window_styles)
   build_window(window_styles, get_search_hyperlinks)
end

function build_window(window_styles, hyperlinks_function)
   ColourNote("paleturquoise", "", "Help Captured To Miniwindow")

   local related_helps, related_categories = hyperlinks_function(window_styles)

   local already_on_screen = false
   if WindowInfo(WINDOW_ID, 1) ~= nil then
      already_on_screen = true
   end

   -- I create a zero-size window first, because MUSHclient has a limitation
   -- where you can only find the width of some text from inside a miniwindow,
   -- and I want to use font metrics to set exactly the right width and height.
   -- I set the defer_showing flag to true because I'm going to move it after
   -- creation and I don't want to see it jump around.
   my_window = ThemedTextWindow(
      WINDOW_ID,  -- id
      0,  -- default_left_position
      0,  -- default_top_position
      0,  -- default_width
      0,  -- default_height
      "Aardwolf In-Game Help",  -- title
      "center",  -- title alignment
      true,  -- is_temporary (closeable)
      true,  -- resizeable
      true,  -- text_scrollable
      true,  -- text_selectable
      true,  -- text_copyable
      true,  -- url_hyperlinks
      true,  -- autowrap
      nil,  -- title_font_name
      nil,  -- title_font_size
      GetAlphaOption("output_font_name"), -- text_font_name
      GetOption("output_font_height"),  -- text_font_size
      nil,  -- text_max_lines
      nil,  -- text_padding
      true  -- defer_showing
   )

   -- Load the contents of the helpfile into the window.
   for i, styles in ipairs(window_styles) do
      my_window:add_text(styles, false, related_helps[i] or related_categories[i])
   end

   -- Now that the window is populated, set the size and position if new.
   if not already_on_screen then
      -- Use window font metrics to set the right width and height, but give 
      -- reasonable maxima so it doesn't go entirely off the screen.
      my_window:fit_contents(
         GetInfo(281)-20,  -- max_width
         GetInfo(280)-80  -- max_height
      )

      -- Use fixed position instead of the auto-centering mode because of a
      -- subtle position retrieval conflict during theme changes between
      -- movewindow and WindowPosition.
      WindowPosition(WINDOW_ID, (GetInfo(281)-my_window.width)/2, (GetInfo(280)-my_window.height)/2, 12, 18)
   end

   -- Make sure we're scrolled up to the top.
   my_window:set_scroll(1)

   -- I used the defer_showing flag, so now I have to show the window.
   my_window:show()

   -- Make sure it isn't behind any other miniwindows.
   my_window:bring_to_front()
end

function OnPluginInstall()
   OnPluginEnable()
end

function OnPluginEnable()
   if IsConnected() then
      OnPluginConnect()
   end
end

function OnPluginConnect()
   Send_GMCP_Packet("tags on")
   TelnetOptionOn(TELOPT_HELPS)
end

function OnPluginDisable()
   if IsConnected() then
      TelnetOptionOff(TELOPT_HELPS)
   end
end

function OnPluginClose()
   OnPluginDisable()
end

function OnPluginThemeChange()
   -- Miniwindow color themes are applied at their creation, so create an
   -- existing window again if the theme changes.
   if my_window and my_window.id then
      build_window(my_window:get_styles())
   end
end

]]>
</script>
</muclient>
